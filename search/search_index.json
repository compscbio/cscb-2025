{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Computational Stem Cell Biology","text":"Level up <p>This is a companion website for the class</p> <p>EN 580.447/647    Computational Stem Cell Biology Spring, 2025 (3 credits, EQ) Please monitor your email and the Canvas page for notifications and announcements.</p>"},{"location":"index.html#education-team","title":"Education Team","text":"<ul> <li> <p>Patrick Cahan, Ph.D. Course Instructor </p> <p>Associate Professor of Biomedical Engineering</p> <p>patrick [dot] cahan [at] jhmi [dot] edu</p> <p>Office hours: Immediately after class on Tues for a quick chat, otherwise email to schedule a time.</p> <p> Cahan Lab</p> </li> <li> <p>Communication </p> <p>Email: compscbio@gmail.com </p> <p>Piazza discussion forum</p> </li> <li> <p>Orian Stapleton Teaching Assistant </p> <p>Ph.D student in Biomedical Engineering</p> <p>ostaple1 [at] jh [dot] edu</p> <p>Office hours: Mondays 7:00pm - 8:00pm via Zoom</p> </li> <li> <p>Gary Yang Teaching Assistant </p> <p>Ph.D student in Biomedical Engineering</p> <p>garyyang [at] jhu [dot] edu</p> <p>Office hours: Wednesdays 7:00pm - 8:00pm in Brody Atrium</p> </li> </ul>"},{"location":"index.html#class-meetings","title":"Class Meetings","text":"<ul> <li>12noon to 1:15 PM on Tuesdays and Thursdays</li> <li>Shaffer Hall Room 3</li> <li>Attendence is encouraged</li> <li>Zoom:<ul> <li>https://wse.zoom.us/j/95896765256</li> <li>Requires authentication via Hopkins SSO to join</li> </ul> </li> </ul>"},{"location":"index.html#course-information","title":"Course Information","text":"<p>This course teaches students about high-throughput, genome-wide single cell measurements, and approaches to appropriately analyze such data. Real world examples from stem cell biology and developmental biology provide the biological context and motivation, but the computational expertise gained will be broadly applicable. Please see the lecture schedule below for specific topics. By the end of this course, the student should</p> <ul> <li>be conversant in the language of sc-omics technologies, both at the level of general principles, and more granular understanding of how these data-generating platforms work</li> <li>be a confident practitioner in state-of-the art computational methods needed to analyze sc-omic data</li> <li>understand the fundamentals of stem cell biology and how sc-omics is allowing us to address major obstacles in this field</li> </ul>"},{"location":"index.html#recommended-background","title":"Recommended Background","text":"<ul> <li>EN.580.151 \u2013 Structural Biology of Cells , or equivalent</li> <li>Prior hands on experience coding in Python </li> <li>Please see some example homeworks from the 2022 course to assess your readiness for the class.</li> </ul>"},{"location":"index.html#course-goals","title":"Course Goals","text":"<p>This course will address the following Criterion 3 Student Outcomes - An ability to apply knowledge of mathematics, science and engineering to solve problems related to stem cell engineering - An ability to analyze and interpret data using statistical, computational or mathematical methods - An ability to function on multidisciplinary teams (Criteria 3(d)) - An understanding of professional and ethical responsibility (Criteria 3(f)) - An ability to communicate effectively (writing) (Criteria 3(g)) - An ability to communicate effectively (oral presentation) (Criteria 3(g))</p>"},{"location":"index.html#course-topics","title":"Course Topics","text":"<ul> <li>Stem cell biology</li> <li>Single cell omics technologies</li> <li>Computational tools for the analysis of single cell omics data</li> </ul>"},{"location":"index.html#ethics","title":"Ethics","text":"<p>The strength of the university depends on academic and personal integrity. In this course, you must be honest and truthful. Ethical violations include plagiarism, reuse of assignments, improper use of the Internet and electronic devices, unauthorized collaboration, alteration of graded assignments, forgery and falsification, lying, facilitating academic dishonesty, and unfair competition. In addition, the specific ethics guidelines for this course are: (1) Homeworks are to be completed by each student alone. Do not share your projects with other students or use material from prior years. (2) The use of Large language models (LLMs) such as ChatGPT are allowed for the homeworks and final project, when doing so is consistent with the stated Course goals and Course expected outcomes (see above). The use of LLMs and similar technology is not allowed for the weekly written summaries. As a guideline, please use LLMs to augment your understanding of the material in the course, to help you to explore algorithmic ideas that might otherwise be challenging to implement, and more generally, to be a more creative problem solver. Report any violations you witness to the instructor.  You can find more information about university misconduct policies on the web at these sites: - For undergraduates: http://e-catalog.jhu.edu/undergrad-students/student-life-policies/ - For graduate students: http://e-catalog.jhu.edu/grad-students/graduate-specific-policies/</p>"},{"location":"index.html#grades","title":"Grades","text":"<ul> <li>Homeworks: 10% per homework. 50% total<ul> <li>Detailed expectations will be described for each HW</li> <li>Individual work; assistance from LLMs is allowed per guidelines in the Ethics section above.</li> </ul> </li> <li>Final project: 50%<ul> <li>Detailed expectations will be described for the project</li> <li>Small teams (3-5 students); assistance from LLMs is allowed per guidelines in the Ethics section above.</li> <li>Entails written and presentation portions</li> </ul> </li> <li>In class quizzes: up to 10% extra credit<ul> <li>These will be available via Zoom, too</li> </ul> </li> <li>Policy on grace periods and extensions:<ul> <li>HWs submitted up to 24 hours late receive a 20 pt penalty</li> <li>HWs submitted between 24 - 48 hours late receive a 50 pt penalty</li> </ul> </li> </ul>"},{"location":"glossary.html","title":"Glossary of terms","text":""},{"location":"lecture_schedule.html","title":"Lecture schedule","text":"<ol> <li>Course introduction and overview</li> <li>Stem cell fundamentals, cell identity, and gene expression </li> <li>How does scRNA-seq work?</li> <li>Fundamentals of scRNA-seq analysis (live analysis) <ol> <li>HW1 assigned</li> </ol> </li> <li>Data integration and cell typing</li> <li>Data integration and cell typing (live analysis) HW2 assigned</li> <li>Bio break: basics of development</li> <li>Pseudotime or trajectory inference</li> <li>Pseudotime analysis in practice (live analysis) HW3 assigned</li> <li>Biobreak: Mechanisms that maintain fate potency</li> <li>Cell potency calculators and lineage tracing</li> <li>Cell potency and lineage tracing analysis (live analysis) HW4 assigned</li> <li>Gene regulatory network inference from gene expression data</li> <li>ATAC-seq</li> <li>Regulatory network analysis (live analysis)</li> <li>Simulation engines and expression forecasting  HW5 assigned</li> <li>Simulation engines and expression forecasting (live analysis) Final project distributed</li> <li>Cell-cell interactions inference</li> <li>Cell-cell interaction (live analysis) HW6 assigned</li> <li>Spatial transcriptomics</li> <li>Spatial transcriptomics (live analysis) </li> <li>RNA velocity</li> <li>RNA velocity (live analysis)</li> <li>Controversies and ethical considerations</li> <li>Final group presentations</li> <li>Final group presentations</li> </ol>"},{"location":"readings.html","title":"Readings","text":"<p>Please try to read the first paper for each week. Other papers listed will be discussed in class and/or will be helpful for the homeworks. In cases where the Pubmed of the paper does not have links to OpenAccess versions of the paper, we will provide a pdf (requires being logged in to Hopkins SSO).</p>"},{"location":"readings.html#week-1-scrna-seq-data-generation","title":"Week 1: scRNA-seq data generation","text":"<ol> <li> <p>Macosko EZ, Basu A, Satija R, et al. Highly Parallel Genome-wide Expression Profiling of Individual Cells Using Nanoliter Droplets. Cell. 2015;161(5):1202-1214. doi:10.1016/j.cell.2015.05.002</p> </li> <li> <p>Zheng GX, Terry JM, Belgrader P, et al. Massively parallel digital transcriptional profiling of single cells. Nat Commun. 2017;8:14049. Published 2017 Jan 16. doi:10.1038/ncomms14049</p> </li> </ol>"},{"location":"readings.html#week-2-scrna-seq-analysis","title":"Week 2: scRNA-seq analysis","text":"<ol> <li>Quality control sections: 6.0 - 6.3</li> <li>Normalization section 7.0 - 7.1</li> <li>PCA 9.0 - 9.1</li> <li>Clustering Whole chapter</li> <li>Manual cell typing 11.0 - 11.4</li> </ol>"},{"location":"readings.html#week-3-integration-and-cell-typing","title":"Week 3: Integration and cell typing","text":""},{"location":"readings.html#typing-and-integration-methods","title":"Typing and integration methods","text":"<ol> <li>Kiselev VY, Yiu A, Hemberg M. scmap: projection of single-cell RNA-seq data across data sets. Nat Methods. 2018 May;15(5):359-362. doi: 10.1038/nmeth.4644</li> <li>Pola\u0144ski K, Young MD, Miao Z, Meyer KB, Teichmann SA, Park JE. BBKNN: fast batch alignment of single cell transcriptomes. Bioinformatics. 2020 Feb 1;36(3):964-965. doi: 10.1093/bioinformatics/btz625</li> <li>Tan Y, Cahan P. SingleCellNet: A Computational Tool to Classify Single Cell RNA-Seq Data Across Platforms and Across Species. Cell Syst. 2019 Aug 28;9(2):207-213.e2. doi: 10.1016/j.cels.2019.06.004. Epub 2019 Jul 31</li> <li>Korsunsky I, Millard N, Fan J, Slowikowski K, Zhang F, Wei K, Baglaenko Y, Brenner M, Loh PR, Raychaudhuri S. Fast, sensitive and accurate integration of single-cell data with Harmony. Nat Methods. 2019 Dec;16(12):1289-1296. doi: 10.1038/s41592-019-0619-0</li> </ol>"},{"location":"readings.html#benchmarking-studes","title":"Benchmarking studes","text":"<ol> <li>Tran HTN, Ang KS, Chevrier M, Zhang X, Lee NYS, Goh M, Chen J. A benchmark of batch-effect correction methods for single-cell RNA sequencing data. Genome Biol. 2020 Jan 16;21(1):12. doi: 10.1186/s13059-019-1850-9</li> <li>Kang JB, Nathan A, Weinand K, Zhang F, Millard N, Rumker L, Moody DB, Korsunsky I, Raychaudhuri S. Efficient and precise single-cell reference atlas mapping with Symphony. Nat Commun. 2021 Oct 7;12(1):5890. doi: 10.1038/s41467-021-25957-x</li> <li>Open problems in Single-cell analysis</li> </ol>"},{"location":"readings.html#week-4-trajectory-inference","title":"Week 4: Trajectory inference","text":"<p>Read the Monocle paper</p> <p>Be sure to read the Monocle paper (#1 below) as it introduces all of the major concepts related to TI and pseudotime.</p>"},{"location":"readings.html#methods","title":"Methods","text":"<ol> <li>Trapnell C, Cacchiarelli D, Grimsby J, Pokharel P, Li S, Morse M, Lennon NJ, Livak KJ, Mikkelsen TS, Rinn JL. The dynamics and regulators of cell fate decisions are revealed by pseudotemporal ordering of single cells. Nat Biotechnol. 2014 Apr;32(4):381-386. doi: 10.1038/nbt.2859. Epub 2014 Mar 23.</li> <li>Faure L, Soldatov R, Kharchenko PV, Adameyko I. scFates: a scalable python package for advanced pseudotime and bifurcation analysis from single-cell data. Bioinformatics. 2023 Jan 1;39(1):btac746. doi: 10.1093/bioinformatics/btac746.</li> <li>Street K, Risso D, Fletcher RB, Das D, Ngai J, Yosef N, Purdom E, Dudoit S. Slingshot: cell lineage and pseudotime inference for single-cell transcriptomics. BMC Genomics. 2018 Jun 19;19(1):477. doi:10.1186/s12864-018-4772-0.</li> </ol>"},{"location":"readings.html#benchmarking","title":"Benchmarking","text":"<ol> <li>Saelens W, Cannoodt R, Todorov H, Saeys Y. A comparison of single-cell trajectory inference methods. Nat Biotechnol. 2019 May;37(5):547-554. doi: 10.1038/s41587-019-0071-9. Epub 2019 Apr 1. PMID: 30936559.</li> </ol>"},{"location":"refs.html","title":"References","text":""},{"location":"videos.html","title":"Videos","text":"<p>Acces to lecture videos is available to current students</p> <p>The lecture videos below can only be viewed after authenticating via Hopkin's SSO</p> <ol> <li>Course introduction and overview</li> <li>Stem cell fundamentals, cell identity, and gene expression </li> <li>How does scRNA-seq work?</li> <li>Fundamentals of scRNA-seq analysis</li> <li>Data integration and cell typing</li> <li>Data integration and cell typing (live analysis) HW2 assigned</li> <li>Bio break: basics of development</li> <li>Pseudotime or trajectory inference</li> <li>Pseudotime analysis in practice (live analysis) HW3 assigned</li> <li>Biobreak: Mechanisms that maintain fate potency</li> <li>Cell potency calculators and lineage tracing</li> <li>Cell potency and lineage tracing analysis (live analysis) HW4 assigned</li> <li>Gene regulatory network inference from gene expression data</li> <li>ATAC-seq</li> <li>Regulatory network analysis (live analysis)</li> <li>Simulation engines and expression forecasting  HW5 assigned</li> <li>Simulation engines and expression forecasting (live analysis) Final project distributed</li> <li>Cell-cell interactions inference</li> <li>Cell-cell interaction (live analysis) HW6 assigned</li> <li>Spatial transcriptomics</li> <li>Spatial transcriptomics (live analysis) </li> <li>RNA velocity</li> <li>RNA velocity (live analysis)</li> <li>Controversies and ethical considerations</li> <li>Final group presentations</li> <li>Final group presentations</li> </ol>"},{"location":"hws/index.html","title":"Guidelines","text":"<p>Each homework entails applying what you have learned in class to analyze real (or realistic) single cell data. In some cases, you will be asked to devise new approaches to analze the data, or to adapt existing ones. In all cases, you will be asked to interpret your results in the context of the literature to which you have been exposed. Each Homework will have a Deliverables section that explicitly states what you must provide to receive full credit. </p> <p>Check you submissions</p> <p>All submissions must include all code necessary to replicate your results. And the must adhere to the posted guidelines for code documentation, cogent written reports, and meaningful figures (see below).</p>"},{"location":"hws/index.html#style-guide-checklist","title":"Style guide checklist","text":"<p>Before turning in your assignments, please consult this checklist. This will make your work easier for us to understand, so that we can grade efficiently and fairly and provide more useful feedback. Check out the style guide example (below) to see what this looks like in practice. </p> <ul> <li>Organization:<ul> <li> The code and answers are in the same order as the questions in the assignment, OR </li> <li> There are reasonable deviations from the prescribed order, but the first chunk provides a table of contents or clear explanation. </li> </ul> </li> <li>Communication:<ul> <li> Statements about data/results are in Markdown chunks, not code comments.</li> <li> Code comments usually answer \"why?\" not \"what?\"[^1]    </li> </ul> </li> </ul> <p>[^1] Our comments will often violate \"why not what\" because we need to convey what the code does to everyone in the class, even if they are new to Python and/or genomics. By contrast, you are writing for an audience with some experience (us), so you should follow \"why not what\" even if you see us breaking this rule.</p>"},{"location":"hws/final_project.html","title":"Example homework assignment","text":"<p>Warning</p> <p>This is not a real assignment for CSCB! It's just a realistic example to demonstrate the style guide.</p>"},{"location":"hws/final_project.html#goal","title":"Goal","text":"<p>The goal of this assignment is to give you some experience in data wrangling and quality control of scRNA-seq data.</p>"},{"location":"hws/final_project.html#due-date-jan-1st-2001","title":"Due date: Jan 1st, 2001.","text":""},{"location":"hws/final_project.html#data","title":"Data","text":"<p>In this assignment, you will perform a few initial steps in the analysis of a dataset from a tech-dev paper showing off an unusual combination of cababilities. The paper includes several large experiments with genetic perturbations followed by a scRNA-seq readout (Replogle et al 2020). These assays are applied to mostly the K562 leukemia cell line.  We'll focus on just the CRISPRa multiplexing experiment, which does gene overexpression followed by scRNA. </p>"},{"location":"hws/final_project.html#your-mission","title":"Your mission","text":""},{"location":"hws/final_project.html#task-1","title":"Task 1","text":"<ul> <li>Tidy the dataset so that it fits in an AnnData object.</li> <li>For each overexpressed gene, how many cells are measured?</li> </ul>"},{"location":"hws/final_project.html#task-2","title":"Task 2","text":"<ul> <li>Compute typical scRNA quality metrics and filter out genes and cells as discussed in class.</li> <li>As you apply each filter, print the number of cells remaining so that anyone following your code can see which filtering steps are most impactful.</li> </ul>"},{"location":"hws/final_project.html#task-3","title":"Task 3","text":"<ul> <li>Write code to visualize the data using scanpy.</li> <li>Run the code and describe the results.</li> </ul>"},{"location":"hws/final_project.html#resources","title":"Resources","text":"<p>You may use the provided code (<code>ingestion.py</code>) to convert gene names from Ensembl gene id's (example: <code>ENSG00000109101</code>) to more readable Entrez gene symbols (example: <code>Foxn1</code>).</p>"},{"location":"hws/final_project.html#deliverables","title":"Deliverables","text":"<p>A Jupyter notebook that contains documented code achieving Tasks 1, 2, and 3. For an example submission, [['HWEX Done']].</p>"},{"location":"hws/guidelines.html","title":"Guidelines","text":"<p>Each homework entails applying what you have learned in class to analyze real (or realistic) single cell data. In some cases, you will be asked to devise new approaches to analze the data, or to adapt existing ones. In all cases, you will be asked to interpret your results in the context of the literature to which you have been exposed. Each Homework will have a Deliverables section that explicitly states what you must provide to receive full credit. </p> <p>Check you submissions</p> <p>All submissions must include all code necessary to replicate your results. And the must adhere to the posted guidelines for code documentation, cogent written reports, and meaningful figures (see below).</p>"},{"location":"hws/guidelines.html#style-guide-checklist","title":"Style guide checklist","text":"<p>Before turning in your assignments, please consult this checklist. This will make your work easier for us to understand, so that we can grade efficiently and fairly and provide more useful feedback. Check out the style guide example (below) to see what this looks like in practice. </p> <ul> <li>Organization:<ul> <li> The code and answers are in the same order as the questions in the assignment, OR </li> <li> There are reasonable deviations from the prescribed order, but the first chunk provides a table of contents or clear explanation. </li> </ul> </li> <li>Communication:<ul> <li> Statements about data/results are in Markdown chunks, not code comments.</li> <li> Code comments usually answer \"why?\" not \"what?\"<sup>1</sup> </li> </ul> </li> </ul> <ol> <li> <p>Our comments will often violate \"why not what\" because we need to convey what the code does to everyone in the class, even if they are new to Python and/or genomics. By contrast, you are writing for an audience with some experience (us), so you should follow \"why not what\" even if you see us breaking this rule.\u00a0\u21a9</p> </li> </ol>"},{"location":"hws/hw_1.html","title":"Homework 1","text":"<p>Homework 1: Fundamentals of scRNA-seq analysis in Python</p> <p>Deadline: Friday, Feb 7th 2025 11:59pm</p>"},{"location":"hws/hw_1.html#background","title":"Background","text":"<p>We discussed hematopoiesis and the types of cells found in peripheral blood mononuclear cells (PBMCs) during Lectures 3-4. We also walked through the analysis of a human PBMC scRNA-seq data set, from CellRanger output to a cleaned anndata object decorated with cell type annotations for each cell. In this homework, you are going to explore what scRNA-seq tells us about PBMC cell type composition, and you are going to explore the impact of varying steps in the analysis pipeline on your estimate of cell type composition.</p> <p>Cell type composition</p> <p>You should think about and compute Cell type composition relative to the total number of cells sampled. For example, after you perform QC on Sample 1, maybe your anndata object has 10,000 cells. Downstream analysis (i.e. all the steps from filtering to annotation) results in 7500 cells labeled as 'T cell'. In this case, the T cell fraction of the cell composition is 75%.</p>"},{"location":"hws/hw_1.html#cell-types-in-pbmcs-and-their-distinctive-genes","title":"Cell types in PBMCs and their distinctive genes","text":""},{"location":"hws/hw_1.html#composition-as-claimed-in-literature","title":"Composition, as claimed in literature","text":"<ul> <li>T cell: 70%</li> <li>B cell: 15%</li> <li>Natural killer (NK) cells: 10%</li> <li>Monocyte: 5%</li> <li>Dendritic cells: 1%</li> </ul>"},{"location":"hws/hw_1.html#marker-genes","title":"Marker genes","text":""},{"location":"hws/hw_1.html#monocytes","title":"Monocytes","text":"<ul> <li>LYZ (Lysozyme), CD14, CD68</li> <li>sub-types:<ul> <li>Classical:  CD14, LYZ, S100A8/S100A9, CCR2</li> <li>Intermediate: FCGR3A (CD16), CD163, IL1B</li> <li>non-classical: CX3CR1, FCGR3A (CD16), CCR5</li> </ul> </li> </ul>"},{"location":"hws/hw_1.html#nk-cell","title":"NK cell","text":"<ul> <li>NCAM1 , KIR2DL1, KIR2DL3, KIR2DL4, KIR3DL1, KIR3DL2, NKG2A/C/E (KLRC1/KLRC2/KLRC3), NKG2D (KLRK1), GNLY, GZMB</li> <li>Note that some are also expressed by subsets of T cell</li> </ul>"},{"location":"hws/hw_1.html#b-cell","title":"B cell","text":"<ul> <li>CD19, CD79A, CD79B, CD20</li> <li>Will leave sub-type exploration to student</li> </ul>"},{"location":"hws/hw_1.html#t-cell","title":"T cell","text":"<ul> <li>CD3D, CD3E, CD3G</li> <li>Will leave sub-type exploration to student</li> </ul>"},{"location":"hws/hw_1.html#dendritic-cell","title":"Dendritic cell","text":"<ul> <li>FLT3, CD11C CD1C</li> <li>CD123 &amp; CLEC4C  (plasmacytoid dendritic cell)</li> </ul>"},{"location":"hws/hw_1.html#granulocytes-and-megakaryocytes","title":"Granulocytes and Megakaryocytes","text":"<ul> <li>were not widely recognized as occupying PBMC</li> <li>If student suspects they may then they should identify and include makers thereof in their analysis.</li> </ul>"},{"location":"hws/hw_1.html#data","title":"Data","text":""},{"location":"hws/hw_1.html#sample-1","title":"Sample 1","text":"<p>This is the same Sample 1 as we used in Lecture 4. Here are some more details: - 10k PBMCs from a Healthy Donor (v3 chemistry) Single Cell Gene Expression Dataset by Cell Ranger 3.0.0 - Peripheral blood mononuclear cells (PBMCs) from a healthy donor (the same cells were used to generate pbmc_1k_v2, pbmc_10k_v3). PBMCs are primary cells with relatively small amounts of RNA (~1pg RNA/cell). - 11,769 cells detected by CellRanger - Sequenced on Illumina NovaSeq with approximately 54,000 reads per cell - 10X Genomics web page for this data - URL to h5 file: https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.h5 - file name: pbmc_10k_v3_filtered_feature_bc_matrix.h5</p> <p>Your mission</p> <p>Analyze the provided data to address the questions listed below</p> <ol> <li> <p>What is the cell type composition of PBMCs of Sample 1?</p> <p>Deliverables:</p> <ul> <li> new .obs column indicating cell type</li> <li> appropriate visualization (i.e. UMAP with clusters labeled, supported by dotplot that shows exwpression of marker genes)</li> </ul> </li> <li> <p>How does this estimate of cell composition compare to prior literature?     To evaluate this rapidly and efficiently, write a function that will take a list of anndata objects that have cell annotations, and produces stacked barplot figure, one bar for scRNAseq, one for proportions from literature. each rectangle in a bar reflects % of sample annotated as cell type X.</p> <p>Deliverables:</p> <ul> <li> The function definition</li> <li> Use of the function to produce the stacked boxplot that shows the cell type proportions from scRNAseq and from literature</li> </ul> </li> <li> <p>What are the transcriptional signatures of each of the PBMC cell types? We know about some genes that are preferentially expressed in each PBMC cell type (in fact, you used some of these to perform cluster annotation). But one of the benefits of performing genome-wide analyses is that it can identify genes previously unlinked to the phenomenon under study. Your task here is to identify all genes that are preferentially expressed in each PBMC cell type. </p> <p>Deliverables:</p> <ul> <li> One list per cell type containing genes defined by the student as 'preferentially  expressed' in the corresponding cell type.</li> <li> Visualization: dot plot showing expression and % cells expressed of the top X genes per cell type</li> </ul> </li> </ol> <p>ALL SUBMISSIONS MUST...</p> <p>... include all code necessary to replicate the results, and must adhere to posted guidelines for code documentation, cogent written reports, and meaningful figures.</p>"},{"location":"hws/hw_2.html","title":"Homework 2","text":""},{"location":"hws/hw_2.html#due-date","title":"Due date","text":""},{"location":"hws/hw_2.html#data","title":"Data","text":""},{"location":"hws/hw_2.html#deliverables","title":"Deliverables","text":""},{"location":"hws/hw_3.html","title":"Homework 3","text":""},{"location":"hws/hw_3.html#due-date","title":"Due date","text":""},{"location":"hws/hw_3.html#data","title":"Data","text":""},{"location":"hws/hw_3.html#deliverables","title":"Deliverables","text":""},{"location":"hws/hw_4.html","title":"Homework 4","text":""},{"location":"hws/hw_4.html#due-date","title":"Due date","text":""},{"location":"hws/hw_4.html#data","title":"Data","text":""},{"location":"hws/hw_4.html#deliverables","title":"Deliverables","text":""},{"location":"hws/hw_5.html","title":"Homework 5","text":""},{"location":"hws/hw_5.html#due-date","title":"Due date","text":""},{"location":"hws/hw_5.html#data","title":"Data","text":""},{"location":"hws/hw_5.html#deliverables","title":"Deliverables","text":""},{"location":"hws/hw_example.html","title":"Example homework assignment","text":"<p>Warning</p> <p>This is not a real assignment for CSCB! It's just a realistic example to demonstrate the style guide.</p>"},{"location":"hws/hw_example.html#goal","title":"Goal","text":"<p>The goal of this assignment is to give you some experience in data wrangling and quality control of scRNA-seq data.</p>"},{"location":"hws/hw_example.html#due-date-jan-1st-2001","title":"Due date: Jan 1st, 2001.","text":""},{"location":"hws/hw_example.html#data","title":"Data","text":"<p>In this assignment, you will perform a few initial steps in the analysis of a dataset from a tech-dev paper showing off an unusual combination of cababilities. The paper includes several large experiments with genetic perturbations followed by a scRNA-seq readout (Replogle et al 2020). These assays are applied to mostly the K562 leukemia cell line.  We'll focus on just the CRISPRa multiplexing experiment, which does gene overexpression followed by scRNA. </p>"},{"location":"hws/hw_example.html#your-mission","title":"Your mission","text":""},{"location":"hws/hw_example.html#task-1","title":"Task 1","text":"<ul> <li>Tidy the dataset so that it fits in an AnnData object.</li> <li>For each overexpressed gene, how many cells are measured?</li> </ul>"},{"location":"hws/hw_example.html#task-2","title":"Task 2","text":"<ul> <li>Compute typical scRNA quality metrics and filter out genes and cells as discussed in class.</li> <li>As you apply each filter, print the number of cells remaining so that anyone following your code can see which filtering steps are most impactful.</li> </ul>"},{"location":"hws/hw_example.html#task-3","title":"Task 3","text":"<ul> <li>Write code to visualize the data using scanpy.</li> <li>Run the code and describe the results.</li> </ul>"},{"location":"hws/hw_example.html#resources","title":"Resources","text":"<p>You may use the provided code (<code>ingestion.py</code>) to convert gene names from Ensembl gene id's (example: <code>ENSG00000109101</code>) to more readable Entrez gene symbols (example: <code>Foxn1</code>).</p>"},{"location":"hws/hw_example.html#deliverables","title":"Deliverables","text":"<p>A Jupyter notebook that contains documented code achieving Tasks 1, 2, and 3. For an example submission, [['HWEX Done']].</p>"},{"location":"lectures/index.html","title":"Lectures","text":"<p>The topics that we cover can be broadly split into three categories: stem cell biology, single cell data generation platforms, and computational methods for analyses of these data.</p> <p>Access to lecture videos is available to current students</p> <p>The lecture videos below can only be viewed after authenticating via Hopkin's SSO</p> Lecture Date Topic link to video lecture slides 1 01-21-25 Course introduction intro to course slides 2 01-23-25 Stem cell biology stem cell basics slides 2 01-23-25 Single cell biology game show video NA 3 01-28-25 scRNAseq data generation dropseq slides 4 01-30-25 Scanpy tutorial scanpy analysis notebook 5 02-04-25 Data integration and cell typing hcl,scmap,bbknn,scn slides 6 02-06-25 Integration &amp; typing tutorial cell typing and integration - 7 02-11-25 Trajectory inference and pseudotime - - 8 02-13-25 TI tutorial - - nc 02-18-25 NC - - nc 02-20-25 NC - - 9 02-25-25 Cell fate potency - - 10 02-27-25 Stemness tutorial - - 11 03-04-25 Gene regulatory networks - - 12 03-06-25 GRN tutorial - - 13 03-11-25 Cell state forecasting - - 14 03-13-25 Forecasting tutorial - -"},{"location":"lectures/topics.html","title":"Lectures","text":"<p>The topics that we cover can be broadly split into three categories: stem cell biology, single cell data generation platforms, and computational methods for analyses of these data.</p> <p>!!warning \"Acces to lecture videos is available to current students\"</p> <pre><code>The lecture videos below can only be viewed after authenticating via [Hopkin's SSO](https://my.jh.edu/html/myjh.html)\n</code></pre> Number Date Topic link to video slides 1 01-21-25 Course introduction video topics/intro.md 2 01-23-25 Single cell biology [topics/"},{"location":"lectures/topics.html#stem-cell-biology","title":"(Stem) cell biology","text":"<p>We will cover some basic cell biology and then discuss the main areas of focus in stem cell biology.</p> <ul> <li>Stem cell biology basics</li> <li>Cell identity</li> <li>Development and differentiation</li> <li>Cell fate engineering</li> <li>Gene regulatory networks</li> <li>Cell-to-cell communication</li> <li>Controversies</li> </ul>"},{"location":"lectures/topics.html#single-cell-data-generation-platforms","title":"Single cell data generation platforms","text":"<p>The course will mainly use scRNA-seq data but we will also discuss other data modalities.</p> <ul> <li>Single cell RNA-seq</li> <li>Single cell ATAC-seq</li> <li>Spatial transcriptomics</li> <li>Lineage tracing</li> </ul>"},{"location":"lectures/topics.html#computational-methods","title":"Computational methods","text":"<p>In addition to the basic standard analysis pipelines, we will also cover more advanced methods.</p> <ul> <li>Integration and cell typing</li> <li>Trajectory inference</li> <li>Fate potential</li> <li>Forecasting and simulations</li> </ul>"},{"location":"notebooks/index.html","title":"Topics","text":"<p>The topics covered can be broadly split into three categories: stem cell biology, single cell data generation platforms, and computational methods for analyses of these data.</p>"},{"location":"notebooks/index.html#stem-cell-biology","title":"(Stem) cell biology","text":"<p>We will cover some basic cell biology and then discuss the main areas of focus in stem cell biology.</p> <ul> <li>Stem cell biology basics</li> <li>Cell identity</li> <li>Development and differentiation</li> <li>Cell fate engineering</li> <li>Gene regulatory networks</li> <li>Cell-to-cell communication</li> <li>Controversies</li> </ul>"},{"location":"notebooks/index.html#single-cell-data-generation-platforms","title":"Single cell data generation platforms","text":"<p>The course will mainly use scRNA-seq data but we will also discuss other data modalities.</p> <ul> <li>Single cell RNA-seq</li> <li>Single cell ATAC-seq</li> <li>Spatial transcriptomics</li> <li>Lineage tracing</li> </ul>"},{"location":"notebooks/index.html#computational-methods","title":"Computational methods","text":"<p>In addition to the basic standard analysis pipelines, we will also cover more advanced methods.</p> <ul> <li>Integration and cell typing</li> <li>Trajectory inference</li> <li>Fate potential</li> <li>Forecasting and simulations</li> </ul>"},{"location":"notebooks/colab.html","title":"Colab","text":""},{"location":"notebooks/colab.html#google-colab","title":"Google Colab\u00b6","text":"<p>You may already know about Jupyter and how to use it. For this course, students are encouraged to use Google's Colab cloud platform to perform analysis of scRNA-seq data. This platform allows users to run analyses on the cloud for free using Jupyter. But, you need a Google account to do so.</p> <ol> <li><p>Please create a Google account, if you do not already have one.</p> </li> <li><p>Log in to your Google account, if you are not already logged in.</p> </li> <li><p>Test your access to Google Colab. You should see a screen like the following:</p> </li> </ol> Screenshot of Colab diaglog box <ol> <li><p>Create a new notebook. If you see the dialog shown above, then click 'create notebook'. You can also create a notebook using the Menu at the top of the page: File -&gt; New notebook in Drive. Either will result in the launching of a new Jupyter notebook.</p> </li> <li><p>The End. You are done and can close the browser page on Colab.</p> </li> </ol>"},{"location":"notebooks/hwex_done.html","title":"HWEX Done","text":"<p>This is not a real assignment for CSCB! It's just a realistic example to demonstrate the style guide.</p> In\u00a0[7]: Copied! <pre>import warnings\nwarnings.filterwarnings('ignore')\nimport os\nimport shutil\nimport importlib\nimport matplotlib.colors as colors\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport scanpy as sc\nimport seaborn as sns\nimport anndata\nfrom IPython.display import display, HTML\n\n# Import the code provided with the assignment\nimport importlib\nimport sys\nsys.path.append(\"setup\")\nimport ingestion\nimportlib.reload(ingestion)\n\n# visualization settings\n%matplotlib inline\nplt.rcParams['figure.figsize'] = [6, 4.5]\nplt.rcParams[\"savefig.dpi\"] = 300\n\n# Some useful gene annotation files\ngeneAnnotationPath = \"../accessory_data/gencode.v35.annotation.gtf.gz\"       # Downloaded from https://www.gencodegenes.org/human/release_35.html\ncellcycleGenePath = \"../accessory_data/regev_lab_cell_cycle_genes.txt\"\n</pre> import warnings warnings.filterwarnings('ignore') import os import shutil import importlib import matplotlib.colors as colors import matplotlib.pyplot as plt import numpy as np import pandas as pd import scanpy as sc import seaborn as sns import anndata from IPython.display import display, HTML  # Import the code provided with the assignment import importlib import sys sys.path.append(\"setup\") import ingestion importlib.reload(ingestion)  # visualization settings %matplotlib inline plt.rcParams['figure.figsize'] = [6, 4.5] plt.rcParams[\"savefig.dpi\"] = 300  # Some useful gene annotation files geneAnnotationPath = \"../accessory_data/gencode.v35.annotation.gtf.gz\"       # Downloaded from https://www.gencodegenes.org/human/release_35.html cellcycleGenePath = \"../accessory_data/regev_lab_cell_cycle_genes.txt\"   In\u00a0[8]: Copied! <pre># Reading from .mtx is slow, so we memoize to h5ad. \ndataset_name = \"replogle\"\nif not os.path.exists(f\"not_ready/{dataset_name}/GSM4367986_exp8/overall.h5ad.gzip\"):\n    expression_quantified = sc.read_10x_mtx(f\"not_ready/{dataset_name}/GSM4367986_exp8/\")\n    expression_quantified.write_h5ad(f\"not_ready/{dataset_name}/GSM4367986_exp8/overall.h5ad.gzip\", compression=\"gzip\")\nelse:\n    expression_quantified = sc.read_h5ad(f\"not_ready/{dataset_name}/GSM4367986_exp8/overall.h5ad.gzip\")\n</pre> # Reading from .mtx is slow, so we memoize to h5ad.  dataset_name = \"replogle\" if not os.path.exists(f\"not_ready/{dataset_name}/GSM4367986_exp8/overall.h5ad.gzip\"):     expression_quantified = sc.read_10x_mtx(f\"not_ready/{dataset_name}/GSM4367986_exp8/\")     expression_quantified.write_h5ad(f\"not_ready/{dataset_name}/GSM4367986_exp8/overall.h5ad.gzip\", compression=\"gzip\") else:     expression_quantified = sc.read_h5ad(f\"not_ready/{dataset_name}/GSM4367986_exp8/overall.h5ad.gzip\") In\u00a0[9]: Copied! <pre># Typical reshaping of data and computation of QC metrics\nsc.pp.calculate_qc_metrics(expression_quantified, inplace = True)\ncell_metadata = pd.read_csv(f\"not_ready/{dataset_name}/GSM4367986_exp8/cell_identities.csv.gz\")\ncell_metadata.index = cell_metadata[\"cell_barcode\"]\ncell_metadata[\"target_symbol\"] = ingestion.convert_ens_to_symbol(\n    cell_metadata[\"target\"], \n    gtf=geneAnnotationPath, \n    strip_version = True)\nexpression_quantified.obs = pd.merge(expression_quantified.obs,\n                                     cell_metadata, \n                                     how = \"left\", \n                                     left_index = True, \n                                     right_index = True)\n\nexpression_quantified.obs[\"has_guide_annotations\"] = pd.notnull(expression_quantified.obs[\"coverage\"]).astype(\"int\")\nexpression_quantified.obs[\"good_coverage\"] = expression_quantified.obs[\"good_coverage\"].astype(\"str\")\nexpression_quantified.raw = expression_quantified.copy()\n</pre> # Typical reshaping of data and computation of QC metrics sc.pp.calculate_qc_metrics(expression_quantified, inplace = True) cell_metadata = pd.read_csv(f\"not_ready/{dataset_name}/GSM4367986_exp8/cell_identities.csv.gz\") cell_metadata.index = cell_metadata[\"cell_barcode\"] cell_metadata[\"target_symbol\"] = ingestion.convert_ens_to_symbol(     cell_metadata[\"target\"],      gtf=geneAnnotationPath,      strip_version = True) expression_quantified.obs = pd.merge(expression_quantified.obs,                                      cell_metadata,                                       how = \"left\",                                       left_index = True,                                       right_index = True)  expression_quantified.obs[\"has_guide_annotations\"] = pd.notnull(expression_quantified.obs[\"coverage\"]).astype(\"int\") expression_quantified.obs[\"good_coverage\"] = expression_quantified.obs[\"good_coverage\"].astype(\"str\") expression_quantified.raw = expression_quantified.copy() In\u00a0[10]: Copied! <pre>expression_quantified = expression_quantified[~expression_quantified.obs.target_symbol.isna(), :]\n</pre> expression_quantified = expression_quantified[~expression_quantified.obs.target_symbol.isna(), :] In\u00a0[11]: Copied! <pre>expression_quantified.var_names = ingestion.convert_ens_to_symbol(\n    expression_quantified.var_names, \n    gtf=geneAnnotationPath, \n)\ndisplay(expression_quantified.var.head())\ndisplay(expression_quantified.var_names[0:5])\n</pre> expression_quantified.var_names = ingestion.convert_ens_to_symbol(     expression_quantified.var_names,      gtf=geneAnnotationPath,  ) display(expression_quantified.var.head()) display(expression_quantified.var_names[0:5]) gene_ids feature_types n_cells_by_counts mean_counts log1p_mean_counts pct_dropout_by_counts total_counts log1p_total_counts RP11-34P13.3 ENSG00000243485 Gene Expression 14 0.000127 0.000127 99.987326 14.0 2.708050 FAM138A ENSG00000237613 Gene Expression 0 0.000000 0.000000 100.000000 0.0 0.000000 OR4F5 ENSG00000186092 Gene Expression 0 0.000000 0.000000 100.000000 0.0 0.000000 RP11-34P13.7 ENSG00000238009 Gene Expression 343 0.003105 0.003100 99.689486 343.0 5.840641 RP11-34P13.8 ENSG00000239945 Gene Expression 55 0.000498 0.000498 99.950209 55.0 4.025352 <pre>Index(['RP11-34P13.3', 'FAM138A', 'OR4F5', 'RP11-34P13.7', 'RP11-34P13.8'], dtype='object')</pre> In\u00a0[13]: Copied! <pre>n_cells_per_target = expression_quantified.obs.groupby(\"target_symbol\")[[\"cell_barcode\"]].count().sort_values(\"cell_barcode\")\nn_cells_per_target.columns = [\"n_cells\"]\nn_cells_per_target.reset_index(inplace = True)\ndisplay(n_cells_per_target)\nplt.rcParams['figure.figsize'] = [6, 9]\n</pre> n_cells_per_target = expression_quantified.obs.groupby(\"target_symbol\")[[\"cell_barcode\"]].count().sort_values(\"cell_barcode\") n_cells_per_target.columns = [\"n_cells\"] n_cells_per_target.reset_index(inplace = True) display(n_cells_per_target) plt.rcParams['figure.figsize'] = [6, 9] target_symbol n_cells 0 CEBPB 212 1 LHX4 238 2 PTPN1 284 3 CDKN1B 303 4 TBX21 315 ... ... ... 59 TTC6 1513 60 RPL30 1712 61 MTOR 1735 62 MAP2K3 1861 63 Non-Targeting 5126 <p>64 rows \u00d7 2 columns</p> In\u00a0[14]: Copied! <pre>sc.pl.highest_expr_genes(expression_quantified, n_top=30, palette=\"Blues\", width=.3)\n</pre> sc.pl.highest_expr_genes(expression_quantified, n_top=30, palette=\"Blues\", width=.3) In\u00a0[15]: Copied! <pre>expression_quantified.var['mt']   = expression_quantified.var_names.str.startswith((\"MT-\"))\nexpression_quantified.var['ribo'] = expression_quantified.var_names.str.startswith((\"RPS\",\"RPL\"))\nexpression_quantified.var['mt'].sum(), expression_quantified.var['ribo'].sum(),\n</pre> expression_quantified.var['mt']   = expression_quantified.var_names.str.startswith((\"MT-\")) expression_quantified.var['ribo'] = expression_quantified.var_names.str.startswith((\"RPS\",\"RPL\")) expression_quantified.var['mt'].sum(), expression_quantified.var['ribo'].sum(),  Out[15]: <pre>(13, 103)</pre> In\u00a0[16]: Copied! <pre>sc.pp.calculate_qc_metrics(expression_quantified, qc_vars=['ribo', 'mt'], percent_top=None, log1p=False, inplace=True)\n</pre> sc.pp.calculate_qc_metrics(expression_quantified, qc_vars=['ribo', 'mt'], percent_top=None, log1p=False, inplace=True) In\u00a0[17]: Copied! <pre>axs = sc.pl.violin(expression_quantified, ['n_genes_by_counts', \n                                           'total_counts', \n                                           'pct_counts_mt', \n                                           'pct_counts_ribo', \n                                           'pct_counts_in_top_50_genes'], \n                   jitter=0.5, multi_panel=True)\n</pre> axs = sc.pl.violin(expression_quantified, ['n_genes_by_counts',                                             'total_counts',                                             'pct_counts_mt',                                             'pct_counts_ribo',                                             'pct_counts_in_top_50_genes'],                     jitter=0.5, multi_panel=True) In\u00a0[18]: Copied! <pre>fig, ax = plt.subplots(1,1,figsize=(2,2))\nsc.pl.scatter(expression_quantified, x='total_counts', y='n_genes_by_counts', ax=ax)\n</pre> fig, ax = plt.subplots(1,1,figsize=(2,2)) sc.pl.scatter(expression_quantified, x='total_counts', y='n_genes_by_counts', ax=ax) In\u00a0[19]: Copied! <pre>print(\"Number of cells: \", expression_quantified.n_obs)\n\n# figure out the total counts == 95 percentile\nthresh = np.percentile(expression_quantified.obs['total_counts'], 99)\nprint(\"99th percentile: \", thresh)\n</pre> print(\"Number of cells: \", expression_quantified.n_obs)  # figure out the total counts == 95 percentile thresh = np.percentile(expression_quantified.obs['total_counts'], 99) print(\"99th percentile: \", thresh) <pre>Number of cells:  60725\n99th percentile:  17000.280000000006\n</pre> In\u00a0[20]: Copied! <pre>expression_quantified = expression_quantified[expression_quantified.obs['total_counts'] &lt; thresh, :].copy()\nprint(\"Number of cells: \", expression_quantified.n_obs)\n</pre> expression_quantified = expression_quantified[expression_quantified.obs['total_counts'] &lt; thresh, :].copy() print(\"Number of cells: \", expression_quantified.n_obs) <pre>Number of cells:  60117\n</pre> In\u00a0[21]: Copied! <pre>expression_quantified = expression_quantified[expression_quantified.obs[\"total_counts\"] &gt;= 2000, :].copy()\nprint(\"Number of cells: \", expression_quantified.n_obs)\n</pre> expression_quantified = expression_quantified[expression_quantified.obs[\"total_counts\"] &gt;= 2000, :].copy() print(\"Number of cells: \", expression_quantified.n_obs) <pre>Number of cells:  58809\n</pre> In\u00a0[22]: Copied! <pre>expression_quantified = expression_quantified[expression_quantified.obs[\"pct_counts_in_top_50_genes\"] &lt;= 40, :].copy()\nprint(\"Number of cells: \", expression_quantified.n_obs)\n</pre> expression_quantified = expression_quantified[expression_quantified.obs[\"pct_counts_in_top_50_genes\"] &lt;= 40, :].copy() print(\"Number of cells: \", expression_quantified.n_obs) <pre>Number of cells:  58589\n</pre> In\u00a0[23]: Copied! <pre># filter for % mt\nexpression_quantified = expression_quantified[expression_quantified.obs['pct_counts_mt'] &lt; 20, :].copy()\nprint(\"Number of cells: \", expression_quantified.n_obs)\n</pre> # filter for % mt expression_quantified = expression_quantified[expression_quantified.obs['pct_counts_mt'] &lt; 20, :].copy() print(\"Number of cells: \", expression_quantified.n_obs) <pre>Number of cells:  58484\n</pre> In\u00a0[24]: Copied! <pre># filter for % ribo &gt; 50%\nexpression_quantified = expression_quantified[expression_quantified.obs['pct_counts_ribo'] &lt; 30, :].copy()\nprint(\"Number of cells: \", expression_quantified.n_obs)\n</pre> # filter for % ribo &gt; 50% expression_quantified = expression_quantified[expression_quantified.obs['pct_counts_ribo'] &lt; 30, :].copy() print(\"Number of cells: \", expression_quantified.n_obs) <pre>Number of cells:  58415\n</pre> In\u00a0[25]: Copied! <pre>\"\"\" To verify the outcome of filtering cells \"\"\"\nsc.pp.calculate_qc_metrics(expression_quantified, qc_vars=['ribo', 'mt'], percent_top=None, log1p=False, inplace=True)\n</pre> \"\"\" To verify the outcome of filtering cells \"\"\" sc.pp.calculate_qc_metrics(expression_quantified, qc_vars=['ribo', 'mt'], percent_top=None, log1p=False, inplace=True) In\u00a0[26]: Copied! <pre>axs = sc.pl.violin(expression_quantified, ['n_genes_by_counts', \n                                           'total_counts', \n                                           'pct_counts_mt', \n                                           'pct_counts_ribo', \n                                           'pct_counts_in_top_50_genes'], \n                   jitter=0.4, multi_panel=True)\n</pre> axs = sc.pl.violin(expression_quantified, ['n_genes_by_counts',                                             'total_counts',                                             'pct_counts_mt',                                             'pct_counts_ribo',                                             'pct_counts_in_top_50_genes'],                     jitter=0.4, multi_panel=True) In\u00a0[27]: Copied! <pre>fig, ax = plt.subplots(1,1,figsize=(2,2))\nsc.pl.scatter(expression_quantified, x='total_counts', y='n_genes_by_counts', ax=ax)\n</pre> fig, ax = plt.subplots(1,1,figsize=(2,2)) sc.pl.scatter(expression_quantified, x='total_counts', y='n_genes_by_counts', ax=ax) In\u00a0[28]: Copied! <pre>print(\"Number of genes: \", expression_quantified.n_vars)\ngThresh = 10\n\nsc.pp.filter_genes(expression_quantified, min_cells=gThresh)\nprint(\"Number of genes: \", expression_quantified.n_vars)\n</pre> print(\"Number of genes: \", expression_quantified.n_vars) gThresh = 10  sc.pp.filter_genes(expression_quantified, min_cells=gThresh) print(\"Number of genes: \", expression_quantified.n_vars) <pre>Number of genes:  33694\nNumber of genes:  18811\n</pre> In\u00a0[30]: Copied! <pre>mito_genes = expression_quantified.var_names.str.startswith('MT-')\nribo_genes = expression_quantified.var_names.str.startswith((\"RPL\",\"RPS\"))\nmalat_gene = expression_quantified.var_names.str.startswith(\"MALAT1\")\n</pre> mito_genes = expression_quantified.var_names.str.startswith('MT-') ribo_genes = expression_quantified.var_names.str.startswith((\"RPL\",\"RPS\")) malat_gene = expression_quantified.var_names.str.startswith(\"MALAT1\") In\u00a0[32]: Copied! <pre>remove = np.add(mito_genes, ribo_genes)\nremove = np.add(remove, malat_gene)\nkeep = np.invert(remove)\nexpression_quantified = expression_quantified[:,keep].copy()\nprint(\"Number of genes: \", expression_quantified.n_vars)\n</pre> remove = np.add(mito_genes, ribo_genes) remove = np.add(remove, malat_gene) keep = np.invert(remove) expression_quantified = expression_quantified[:,keep].copy() print(\"Number of genes: \", expression_quantified.n_vars) <pre>Number of genes:  18700\n</pre> In\u00a0[33]: Copied! <pre>[idx for idx, n in enumerate(expression_quantified.var.index) if n.upper() == 'GAPDH']\n</pre> [idx for idx, n in enumerate(expression_quantified.var.index) if n.upper() == 'GAPDH'] Out[33]: <pre>[11180]</pre> In\u00a0[34]: Copied! <pre>sc.pl.highest_expr_genes(expression_quantified, n_top=20, palette=\"Blues\", width=.3)\n</pre> sc.pl.highest_expr_genes(expression_quantified, n_top=20, palette=\"Blues\", width=.3) In\u00a0[35]: Copied! <pre>\"\"\" To verify the outcome of filtering genes \"\"\"\nsc.pp.calculate_qc_metrics(expression_quantified, qc_vars=['ribo', 'mt'], percent_top=None, log1p=False, inplace=True)\n</pre> \"\"\" To verify the outcome of filtering genes \"\"\" sc.pp.calculate_qc_metrics(expression_quantified, qc_vars=['ribo', 'mt'], percent_top=None, log1p=False, inplace=True) In\u00a0[36]: Copied! <pre>axs = sc.pl.violin(expression_quantified, ['n_genes_by_counts', \n                                           'total_counts', \n                                           'pct_counts_mt', \n                                           'pct_counts_ribo', \n                                           'pct_counts_in_top_50_genes'], \n                   jitter=0.4, multi_panel=True)\n</pre> axs = sc.pl.violin(expression_quantified, ['n_genes_by_counts',                                             'total_counts',                                             'pct_counts_mt',                                             'pct_counts_ribo',                                             'pct_counts_in_top_50_genes'],                     jitter=0.4, multi_panel=True) In\u00a0[37]: Copied! <pre>fig, ax = plt.subplots(1,1,figsize=(2,2))\nsc.pl.scatter(expression_quantified, x='total_counts', y='n_genes_by_counts', ax=ax)\n</pre> fig, ax = plt.subplots(1,1,figsize=(2,2)) sc.pl.scatter(expression_quantified, x='total_counts', y='n_genes_by_counts', ax=ax) In\u00a0[44]: Copied! <pre>sc.pp.log1p(expression_quantified)\nsc.pp.highly_variable_genes(expression_quantified, min_mean=0.2, max_mean=4, min_disp=0.2, n_bins=50)\nsc.pl.highly_variable_genes(expression_quantified)\nwith warnings.catch_warnings():\n    sc.tl.pca(expression_quantified, n_comps=100)\nsc.pp.neighbors(expression_quantified)\nsc.tl.umap(expression_quantified)\nclusterResolutions = []\nsc.tl.leiden(expression_quantified)\ncc_genes = pd.read_csv(cellcycleGenePath, header = None)[0]\nsc.tl.score_genes_cell_cycle(expression_quantified, s_genes=cc_genes[:43], g2m_genes=cc_genes[43:])\nplt.rcParams['figure.figsize'] = [6, 4.5]\n</pre> sc.pp.log1p(expression_quantified) sc.pp.highly_variable_genes(expression_quantified, min_mean=0.2, max_mean=4, min_disp=0.2, n_bins=50) sc.pl.highly_variable_genes(expression_quantified) with warnings.catch_warnings():     sc.tl.pca(expression_quantified, n_comps=100) sc.pp.neighbors(expression_quantified) sc.tl.umap(expression_quantified) clusterResolutions = [] sc.tl.leiden(expression_quantified) cc_genes = pd.read_csv(cellcycleGenePath, header = None)[0] sc.tl.score_genes_cell_cycle(expression_quantified, s_genes=cc_genes[:43], g2m_genes=cc_genes[43:]) plt.rcParams['figure.figsize'] = [6, 4.5]  <pre>WARNING: adata.X seems to be already log-transformed.\n</pre> <pre>WARNING: genes are not in var_names and ignored: ['MLF1IP']\n</pre> In\u00a0[43]: Copied! <pre>sc.pl.umap(expression_quantified, color = [\n    # \"PTPRC\",\n    \"leiden\", \n    'total_counts', \n    'log1p_total_counts',\n    'pct_counts_in_top_50_genes', \n    'has_guide_annotations',\n    \"phase\",\n    \"target_symbol\",\n])\n</pre> sc.pl.umap(expression_quantified, color = [     # \"PTPRC\",     \"leiden\",      'total_counts',      'log1p_total_counts',     'pct_counts_in_top_50_genes',      'has_guide_annotations',     \"phase\",     \"target_symbol\", ]) <pre>Index(['n_genes_by_counts', 'log1p_n_genes_by_counts', 'total_counts',\n       'log1p_total_counts', 'pct_counts_in_top_50_genes',\n       'pct_counts_in_top_100_genes', 'pct_counts_in_top_200_genes',\n       'pct_counts_in_top_500_genes', 'cell_barcode', 'guide_identity',\n       'num_guides', 'gene', 'best_gamma', 'correction', 'distance', 'gamma_A',\n       'gamma_B', 'gene_type', 'protospacer_A', 'protospacer_B', 'rank_A',\n       'rank_B', 'sgID_A', 'sgID_B', 'type', 'target', 'umi_A', 'umi_B',\n       'read_count', 'UMI_count', 'coverage', 'good_coverage',\n       'number_of_cells', 'gemgroup', 'target_symbol', 'has_guide_annotations',\n       'total_counts_ribo', 'pct_counts_ribo', 'total_counts_mt',\n       'pct_counts_mt', 'leiden', 'S_score', 'G2M_score', 'phase'],\n      dtype='object')\n</pre>"},{"location":"notebooks/hwex_done.html#organization","title":"Organization\u00b6","text":"<p>After the usual imports, we follow the order as described in the assignment, except that out of convenience, some QC metrics are computed before the data reshaping is done.</p>"},{"location":"notebooks/hwex_done.html#1-tidy-the-dataset-so-that-it-fits-in-an-anndata-object","title":"1. Tidy the dataset so that it fits in an AnnData object.\u00b6","text":""},{"location":"notebooks/hwex_done.html#11-for-each-overexpressed-gene-how-many-cells-are-measured","title":"1.1 For each overexpressed gene, how many cells are measured?\u00b6","text":"<p>The code below shows that between 212 and 1861 cells are measured for any given perturbation, with ~5k controls.</p>"},{"location":"notebooks/hwex_done.html#2-compute-typical-scrna-quality-metrics-and-filter-out-genes-and-cells-as-discussed-in-class","title":"2. Compute typical scRNA quality metrics and filter out genes and cells as discussed in class.\u00b6","text":"<p>For this particular project, we prefer to err on the side of discarding real cells rather than risking inclusion of empty droplets, doublets, or other artifacts in our analysis. Out of an abundance of caution, we remove droplets with especially high or low total counts, and we remove droplets with high fractions of RNA from mitochondrial RNA's, ribosomal protein subunit RNA's, or high-expressed RNA's. Please consult the code below for exact thresholds and numbers.</p>"},{"location":"notebooks/hwex_done.html#basic-eda","title":"Basic EDA\u00b6","text":"<p>Visualize the data using scanpy.</p>"},{"location":"notebooks/hwex_done.html#31-run-the-code-and-describe-the-results","title":"3.1 Run the code and describe the results.\u00b6","text":"<p>The UMAP shows a roughly unimodal distribution a lot of variation driven by cell cycle and read depth. Cells do not obviously cluster by which gene was overexpressed. This suggests that most of these perturbations do not cause extensive reprogramming of cell state.</p>"},{"location":"notebooks/scBasics.html","title":"scRNA-seq","text":"<p>hide:</p> <ul> <li>toc</li> </ul> Fundamentals of scRNA-seq analysis in Python Lecture 3, 10-28-2025 This notebook is part the course 580.447/647 Computational Stem Cell Biology taught by Patrick Cahan at Johns Hopkins University in Winter/Spring 2024. Many parts of this tutorial are derived from the sources listed in the Resources section at the end of this notebook. ### Objectives for today After completing this tutorial, students will be familiar with: 1. Basics of Scanpy \t1. annData \t2. loading and saving files \t3. getting var info \t4. getting more help: scanpy docs, tutorials, ChatGPT 2. Quality control 3. Normalization 4. Dimension reduction 5. Cell-cell distance 6. Unsupervised clustering 7. Differential gene expression 8. Cell annotation  <p>Here is a more detailed glimpse of what is happening here:</p> CellRanger flow chart 2 from 10X genomics CellRanger mapping from 10X genomics In\u00a0[1]: Copied! <pre># !pip install scanpy scipy umap-learn leidenalg\n</pre> # !pip install scanpy scipy umap-learn leidenalg In\u00a0[2]: Copied! <pre># wget for linux/unix\n# !wget https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.h5\n# !wget https://cf.10xgenomics.com/samples/cell-exp/6.1.0/20k_PBMC_3p_HT_nextgem_Chromium_X/20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5\n\n# curl for macOS; i have no clue what to use for Windows\n# !curl https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.h5 -o pbmc_10k_v3_filtered_feature_bc_matrix.h5\n# !curl https://cf.10xgenomics.com/samples/cell-exp/6.1.0/20k_PBMC_3p_HT_nextgem_Chromium_X/20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5 -o 20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5\n</pre> # wget for linux/unix # !wget https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.h5 # !wget https://cf.10xgenomics.com/samples/cell-exp/6.1.0/20k_PBMC_3p_HT_nextgem_Chromium_X/20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5  # curl for macOS; i have no clue what to use for Windows # !curl https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.h5 -o pbmc_10k_v3_filtered_feature_bc_matrix.h5 # !curl https://cf.10xgenomics.com/samples/cell-exp/6.1.0/20k_PBMC_3p_HT_nextgem_Chromium_X/20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5 -o 20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5 In\u00a0[3]: Copied! <pre>import scanpy as sc\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport warnings\n# warnings.filterwarnings('ignore')\nplt.rcParams['figure.dpi'] = 300\nsc.logging.print_header()\n</pre> import scanpy as sc import numpy as np import pandas as pd import matplotlib.pyplot as plt import warnings # warnings.filterwarnings('ignore') plt.rcParams['figure.dpi'] = 300 sc.logging.print_header() <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scnpy/lib/python3.12/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> <pre>scanpy==1.10.4 anndata==0.11.3 umap==0.5.7 numpy==1.26.4 scipy==1.14.1 pandas==2.2.3 scikit-learn==1.6.1 statsmodels==0.14.4 igraph==0.11.8 pynndescent==0.5.13\n</pre> In\u00a0[4]: Copied! <pre># I have stored these data files in another dir\nad10f = sc.read_10x_h5(\"data/pbmc_10k_v3_filtered_feature_bc_matrix.h5\")\n# If you stored yours in the cwd on Colab, you should uncomment and run this line instead to load your data:\n# ad10f = sc.read_10x_h5(\"pbmc_10k_v3_filtered_feature_bc_matrix.h5\")\n</pre> # I have stored these data files in another dir ad10f = sc.read_10x_h5(\"data/pbmc_10k_v3_filtered_feature_bc_matrix.h5\") # If you stored yours in the cwd on Colab, you should uncomment and run this line instead to load your data: # ad10f = sc.read_10x_h5(\"pbmc_10k_v3_filtered_feature_bc_matrix.h5\") <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scnpy/lib/python3.12/site-packages/anndata/_core/anndata.py:1758: UserWarning: Variable names are not unique. To make them unique, call `.var_names_make_unique`.\n  utils.warn_names_duplicates(\"var\")\n/opt/homebrew/Caskroom/miniforge/base/envs/scnpy/lib/python3.12/site-packages/anndata/_core/anndata.py:1758: UserWarning: Variable names are not unique. To make them unique, call `.var_names_make_unique`.\n  utils.warn_names_duplicates(\"var\")\n</pre> In\u00a0[5]: Copied! <pre>ad10f.var_names_make_unique()\n\n#?sc.read_10x_h5\n</pre> ad10f.var_names_make_unique()  #?sc.read_10x_h5 In\u00a0[6]: Copied! <pre>print(ad10f)\n</pre> print(ad10f) <pre>AnnData object with n_obs \u00d7 n_vars = 11769 \u00d7 33538\n    var: 'gene_ids', 'feature_types', 'genome'\n</pre> In\u00a0[7]: Copied! <pre>ad10f.shape\n</pre> ad10f.shape Out[7]: <pre>(11769, 33538)</pre> In\u00a0[8]: Copied! <pre>type(ad10f)\n</pre> type(ad10f) Out[8]: <pre>anndata._core.anndata.AnnData</pre> In\u00a0[9]: Copied! <pre>ncells = 3\nngenes = 4\nrandGenes = np.random.choice(ad10f.var_names, size=ngenes, replace=False)\nrandCells = np.random.choice(ad10f.obs_names, size=ncells, replace=False)\n</pre> ncells = 3 ngenes = 4 randGenes = np.random.choice(ad10f.var_names, size=ngenes, replace=False) randCells = np.random.choice(ad10f.obs_names, size=ncells, replace=False) In\u00a0[10]: Copied! <pre>print(randCells)\n</pre> print(randCells) <pre>['TTCCACGCAGACGATG-1' 'CATTGCCAGGTACAAT-1' 'ACTTTCAGTTGAGAGC-1']\n</pre> In\u00a0[11]: Copied! <pre>print(randGenes)\n</pre> print(randGenes) <pre>['AC130352.1' 'AC092354.2' 'MOAP1' 'POLR3B']\n</pre> In\u00a0[12]: Copied! <pre>newAnndata = ad10f[ randCells ]\nnewAnndata\n</pre> newAnndata = ad10f[ randCells ] newAnndata Out[12]: <pre>View of AnnData object with n_obs \u00d7 n_vars = 3 \u00d7 33538\n    var: 'gene_ids', 'feature_types', 'genome'</pre> In\u00a0[13]: Copied! <pre>ad10f[ randGenes ]\n</pre> ad10f[ randGenes ] <pre>\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[13], line 1\n----&gt; 1 ad10f[ randGenes ]\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/scnpy/lib/python3.12/site-packages/anndata/_core/anndata.py:1022, in AnnData.__getitem__(self, index)\n   1020 def __getitem__(self, index: Index) -&gt; AnnData:\n   1021     \"\"\"Returns a sliced view of the object.\"\"\"\n-&gt; 1022     oidx, vidx = self._normalize_indices(index)\n   1023     return AnnData(self, oidx=oidx, vidx=vidx, asview=True)\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/scnpy/lib/python3.12/site-packages/anndata/_core/anndata.py:1003, in AnnData._normalize_indices(self, index)\n   1002 def _normalize_indices(self, index: Index | None) -&gt; tuple[slice, slice]:\n-&gt; 1003     return _normalize_indices(index, self.obs_names, self.var_names)\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/scnpy/lib/python3.12/site-packages/anndata/_core/index.py:32, in _normalize_indices(index, names0, names1)\n     30     index = tuple(i.values if isinstance(i, pd.Series) else i for i in index)\n     31 ax0, ax1 = unpack_index(index)\n---&gt; 32 ax0 = _normalize_index(ax0, names0)\n     33 ax1 = _normalize_index(ax1, names1)\n     34 return ax0, ax1\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/scnpy/lib/python3.12/site-packages/anndata/_core/index.py:105, in _normalize_index(indexer, index)\n    103         if np.any(positions &lt; 0):\n    104             not_found = indexer[positions &lt; 0]\n--&gt; 105             raise KeyError(\n    106                 f\"Values {list(not_found)}, from {list(indexer)}, \"\n    107                 \"are not valid obs/ var names or indices.\"\n    108             )\n    109         return positions  # np.ndarray[int]\n    110 raise IndexError(f\"Unknown indexer {indexer!r} of type {type(indexer)}\")\n\nKeyError: \"Values ['AC130352.1', 'AC092354.2', 'MOAP1', 'POLR3B'], from ['AC130352.1', 'AC092354.2', 'MOAP1', 'POLR3B'], are not valid obs/ var names or indices.\"</pre> In\u00a0[14]: Copied! <pre>ad10f[:, randGenes ]\n</pre> ad10f[:, randGenes ] Out[14]: <pre>View of AnnData object with n_obs \u00d7 n_vars = 11769 \u00d7 4\n    var: 'gene_ids', 'feature_types', 'genome'</pre> In\u00a0[15]: Copied! <pre>gname_counts = ad10f.var_names.value_counts()\nprint(gname_counts)\nnp.any(gname_counts&gt;1)\n</pre> gname_counts = ad10f.var_names.value_counts() print(gname_counts) np.any(gname_counts&gt;1) <pre>MIR1302-2HG    1\nDCT            1\nGPC6-AS2       1\nGPC6           1\nAL354811.1     1\n              ..\nORC3           1\nRARS2          1\nSLC35A1        1\nAL049697.1     1\nFAM231C        1\nName: count, Length: 33538, dtype: int64\n</pre> Out[15]: <pre>False</pre> In\u00a0[16]: Copied! <pre>duplicates = gname_counts[gname_counts &gt; 1]\nprint(duplicates)\n</pre> duplicates = gname_counts[gname_counts &gt; 1] print(duplicates) <pre>Series([], Name: count, dtype: int64)\n</pre> In\u00a0[17]: Copied! <pre>ad10f.var_names_make_unique()\nad10f[:, randGenes ]\n</pre> ad10f.var_names_make_unique() ad10f[:, randGenes ] Out[17]: <pre>View of AnnData object with n_obs \u00d7 n_vars = 11769 \u00d7 4\n    var: 'gene_ids', 'feature_types', 'genome'</pre> In\u00a0[18]: Copied! <pre>ad10f[randCells, randGenes ]\n</pre> ad10f[randCells, randGenes ] Out[18]: <pre>View of AnnData object with n_obs \u00d7 n_vars = 3 \u00d7 4\n    var: 'gene_ids', 'feature_types', 'genome'</pre> Views Views are pointers to memory where original anndata is stored. They are not copies of the variable.   In\u00a0[19]: Copied! <pre>ad10f[randCells, randGenes ].X\n</pre> ad10f[randCells, randGenes ].X Out[19]: <pre>&lt;Compressed Sparse Row sparse matrix of dtype 'float32'\n\twith 1 stored elements and shape (3, 4)&gt;</pre> In\u00a0[20]: Copied! <pre>print(ad10f.obs.columns)\n</pre> print(ad10f.obs.columns) <pre>Index([], dtype='object')\n</pre> In\u00a0[21]: Copied! <pre>ad10f.obs['sample_name'] = \"sample_1\"\nprint(ad10f.obs.columns)\n</pre> ad10f.obs['sample_name'] = \"sample_1\" print(ad10f.obs.columns) <pre>Index(['sample_name'], dtype='object')\n</pre> In\u00a0[22]: Copied! <pre>print(ad10f[randCells].obs)\n</pre> print(ad10f[randCells].obs) <pre>                   sample_name\nTTCCACGCAGACGATG-1    sample_1\nCATTGCCAGGTACAAT-1    sample_1\nACTTTCAGTTGAGAGC-1    sample_1\n</pre> In\u00a0[23]: Copied! <pre>print(ad10f.var.columns)\n</pre> print(ad10f.var.columns) <pre>Index(['gene_ids', 'feature_types', 'genome'], dtype='object')\n</pre> In\u00a0[24]: Copied! <pre>print(ad10f[:,randGenes].var)\n</pre> print(ad10f[:,randGenes].var) <pre>                   gene_ids    feature_types  genome\nAC130352.1  ENSG00000270154  Gene Expression  GRCh38\nAC092354.2  ENSG00000272370  Gene Expression  GRCh38\nMOAP1       ENSG00000165943  Gene Expression  GRCh38\nPOLR3B      ENSG00000013503  Gene Expression  GRCh38\n</pre> In\u00a0[25]: Copied! <pre>print(ad10f.var.loc[randGenes])\n</pre> print(ad10f.var.loc[randGenes]) <pre>                   gene_ids    feature_types  genome\nAC130352.1  ENSG00000270154  Gene Expression  GRCh38\nAC092354.2  ENSG00000272370  Gene Expression  GRCh38\nMOAP1       ENSG00000165943  Gene Expression  GRCh38\nPOLR3B      ENSG00000013503  Gene Expression  GRCh38\n</pre> In\u00a0[26]: Copied! <pre>ad10f.var['mt'] = ad10f.var_names.str.startswith('MT-')\nribo_prefix = (\"RPS\",\"RPL\")\nad10f.var['ribo'] = ad10f.var_names.str.startswith(ribo_prefix)\nsc.pp.calculate_qc_metrics(ad10f, qc_vars=['mt','ribo'], percent_top=None, log1p=False, inplace=True)\n</pre> ad10f.var['mt'] = ad10f.var_names.str.startswith('MT-') ribo_prefix = (\"RPS\",\"RPL\") ad10f.var['ribo'] = ad10f.var_names.str.startswith(ribo_prefix) sc.pp.calculate_qc_metrics(ad10f, qc_vars=['mt','ribo'], percent_top=None, log1p=False, inplace=True) In\u00a0[27]: Copied! <pre>adClean = ad10f.copy()\n\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(10,4), gridspec_kw={'wspace':0.25}, constrained_layout=True)\nax1_dict = sc.pl.scatter(adClean, x='total_counts', y='pct_counts_mt', ax=ax1, show=False)\nax2_dict = sc.pl.scatter(adClean, x='total_counts', y='n_genes_by_counts',ax=ax2, show=False)\nax3_dict = sc.pl.scatter(adClean, x='pct_counts_ribo', y='n_genes_by_counts',ax=ax3, show=False)\nplt.show()\n</pre> adClean = ad10f.copy()  fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(10,4), gridspec_kw={'wspace':0.25}, constrained_layout=True) ax1_dict = sc.pl.scatter(adClean, x='total_counts', y='pct_counts_mt', ax=ax1, show=False) ax2_dict = sc.pl.scatter(adClean, x='total_counts', y='n_genes_by_counts',ax=ax2, show=False) ax3_dict = sc.pl.scatter(adClean, x='pct_counts_ribo', y='n_genes_by_counts',ax=ax3, show=False) plt.show() <p>Now, do the filtering.</p> <p>First, keep cells with fewer than 20% mitochondrially encoded gene total UMIs</p> In\u00a0[28]: Copied! <pre>adClean = adClean[adClean.obs['pct_counts_mt']&lt;20,:].copy()\nadClean.n_obs\n</pre> adClean = adClean[adClean.obs['pct_counts_mt']&lt;20,:].copy() adClean.n_obs Out[28]: <pre>11047</pre> <p>Second, filter based on total number of genes detected (at least 500). Third, filter based on total number of counts (fewer than than 30,000) Fourth, keep genes that are detected in at least 3 cells.</p> In\u00a0[29]: Copied! <pre>sc.pp.filter_cells(adClean, min_genes=500)\nprint(adClean.n_obs)\n\nsc.pp.filter_cells(adClean, max_counts=30000)\nprint(adClean.n_obs)\n\nsc.pp.filter_genes(adClean, min_cells=3)\nprint(adClean.shape)\n</pre> sc.pp.filter_cells(adClean, min_genes=500) print(adClean.n_obs)  sc.pp.filter_cells(adClean, max_counts=30000) print(adClean.n_obs)  sc.pp.filter_genes(adClean, min_cells=3) print(adClean.shape) <pre>10924\n10891\n(10891, 20181)\n</pre> In\u00a0[30]: Copied! <pre>adNorm = adClean.copy()\nadNorm.layers['counts'] = adNorm.X.copy()\nsc.pp.normalize_total(adNorm , target_sum=1e4)\nsc.pp.log1p(adNorm)\nadNorm.layers['lognorm'] = adNorm.X.copy()\n</pre> adNorm = adClean.copy() adNorm.layers['counts'] = adNorm.X.copy() sc.pp.normalize_total(adNorm , target_sum=1e4) sc.pp.log1p(adNorm) adNorm.layers['lognorm'] = adNorm.X.copy() In\u00a0[31]: Copied! <pre>sc.pp.highly_variable_genes(adNorm , min_mean=0.0125, max_mean=6, min_disp=0.25)\nadNorm.var\n</pre> sc.pp.highly_variable_genes(adNorm , min_mean=0.0125, max_mean=6, min_disp=0.25) adNorm.var Out[31]: gene_ids feature_types genome mt ribo n_cells_by_counts mean_counts pct_dropout_by_counts total_counts n_cells highly_variable means dispersions dispersions_norm AL627309.1 ENSG00000238009 Gene Expression GRCh38 False False 60 0.005183 99.490186 61.0 60 False 0.007519 0.595591 -0.001919 AL627309.3 ENSG00000239945 Gene Expression GRCh38 False False 4 0.000340 99.966012 4.0 4 False 0.000389 0.144284 -1.366927 AL669831.5 ENSG00000237491 Gene Expression GRCh38 False False 679 0.062367 94.230606 734.0 665 False 0.077585 0.586329 -0.029932 FAM87B ENSG00000177757 Gene Expression GRCh38 False False 13 0.001190 99.889540 14.0 13 False 0.001139 0.169543 -1.290532 LINC00115 ENSG00000225880 Gene Expression GRCh38 False False 350 0.031269 97.026085 368.0 337 False 0.038579 0.459107 -0.414723 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... AC011043.1 ENSG00000276256 Gene Expression GRCh38 False False 77 0.006882 99.345739 81.0 74 False 0.010262 0.738345 0.429851 AL592183.1 ENSG00000273748 Gene Expression GRCh38 False False 32 0.002719 99.728099 32.0 30 False 0.003977 0.799225 0.613985 AC007325.4 ENSG00000278817 Gene Expression GRCh38 False False 239 0.020902 97.969241 246.0 233 False 0.023936 0.329110 -0.807909 AL354822.1 ENSG00000278384 Gene Expression GRCh38 False False 319 0.028210 97.289489 332.0 303 False 0.038089 0.594378 -0.005588 AC240274.1 ENSG00000271254 Gene Expression GRCh38 False False 101 0.008752 99.141813 103.0 99 False 0.010213 0.301150 -0.892475 <p>20181 rows \u00d7 14 columns</p> In\u00a0[32]: Copied! <pre>sc.pl.highly_variable_genes(adNorm)\n</pre> sc.pl.highly_variable_genes(adNorm) In\u00a0[33]: Copied! <pre>sc.tl.pca(adNorm , mask_var='highly_variable')\n</pre> sc.tl.pca(adNorm , mask_var='highly_variable') In\u00a0[34]: Copied! <pre>markerGenes = ['CD14','CLEC4C', 'CD19',  'GNLY', 'CD3D']\nsc.pl.pca(adNorm , color=markerGenes, ncols=2, layer='counts')\n</pre> markerGenes = ['CD14','CLEC4C', 'CD19',  'GNLY', 'CD3D'] sc.pl.pca(adNorm , color=markerGenes, ncols=2, layer='counts') In\u00a0[35]: Copied! <pre>sc.pl.pca(adNorm , color=markerGenes, ncols=2)\n</pre> sc.pl.pca(adNorm , color=markerGenes, ncols=2) In\u00a0[36]: Copied! <pre>sc.pl.pca(adNorm, color=['total_counts', 'pct_counts_mt', 'pct_counts_ribo'], s=25,ncols=3)\n</pre> sc.pl.pca(adNorm, color=['total_counts', 'pct_counts_mt', 'pct_counts_ribo'], s=25,ncols=3) In\u00a0[37]: Copied! <pre>sc.pl.pca_variance_ratio(adNorm, 50)\n</pre> sc.pl.pca_variance_ratio(adNorm, 50) In\u00a0[38]: Copied! <pre>np.shape(adNorm.varm[\"PCs\"])\n</pre> np.shape(adNorm.varm[\"PCs\"]) Out[38]: <pre>(20181, 50)</pre> <p>Where are the PC values of each cell (i.e. the PC scores) stored in anndata? .obsm</p> In\u00a0[39]: Copied! <pre>np.shape(adNorm.obsm[\"X_pca\"])\n</pre> np.shape(adNorm.obsm[\"X_pca\"]) Out[39]: <pre>(10891, 50)</pre> In\u00a0[40]: Copied! <pre>n_neighbors = 20\nn_pcs = 10\nsc.pp.neighbors(adNorm, n_neighbors=n_neighbors, n_pcs=n_pcs)\n</pre> n_neighbors = 20 n_pcs = 10 sc.pp.neighbors(adNorm, n_neighbors=n_neighbors, n_pcs=n_pcs) In\u00a0[41]: Copied! <pre>sc.tl.umap(adNorm, 0.25)\n</pre> sc.tl.umap(adNorm, 0.25) <pre>/var/folders/1_/v5grqr5n7kj42276bb6ryxj00000gn/T/ipykernel_66578/2021512077.py:1: FutureWarning: The specified parameters ('min_dist',) are no longer positional. Please specify them like `min_dist=0.25`\n  sc.tl.umap(adNorm, 0.25)\n</pre> In\u00a0[42]: Copied! <pre>sc.pl.umap(adNorm, color=markerGenes, alpha=.75, s=15, ncols=2)\n</pre> sc.pl.umap(adNorm, color=markerGenes, alpha=.75, s=15, ncols=2) In\u00a0[43]: Copied! <pre>sc.tl.leiden(adNorm,.1)\n</pre> sc.tl.leiden(adNorm,.1) <pre>/var/folders/1_/v5grqr5n7kj42276bb6ryxj00000gn/T/ipykernel_66578/3992796732.py:1: FutureWarning: In the future, the default backend for leiden will be igraph instead of leidenalg.\n\n To achieve the future defaults please pass: flavor=\"igraph\" and n_iterations=2.  directed must also be False to work with igraph's implementation.\n  sc.tl.leiden(adNorm,.1)\n</pre> In\u00a0[44]: Copied! <pre>sc.pl.umap(adNorm,color=['leiden'], alpha=.75, s=15, legend_loc='on data')\n</pre> sc.pl.umap(adNorm,color=['leiden'], alpha=.75, s=15, legend_loc='on data') Discordance Embeddings do not always agree with cluster results! See cluster 2 above.  <p>We can try to rectify this by using PAGA, which tries to infer dynamic relationships between clusters, to seed an initial embedding for UMAP that reflects overall cluster similarities.</p> <p>In the next cell, we call the following functions</p> <p><code>tl.paga()</code> computes intercluster similarities</p> <p><code>pl.paga()</code> creates an intial embedding based on this</p> <p><code>tl.umap()</code> uses this embedding to start its optimization</p> <p>Let's restart with the cleaned data.</p> In\u00a0[45]: Copied! <pre>adNorm = adClean.copy()\n\n## Norm, HVG, PCA, kNN\nsc.pp.normalize_total(adNorm , target_sum=1e4)\nsc.pp.log1p(adNorm)\nsc.pp.highly_variable_genes(adNorm , min_mean=0.0125, max_mean=6, min_disp=0.25)\nsc.tl.pca(adNorm , use_highly_variable=True)\n\nn_neighbors = 20\nn_pcs = 10\nsc.pp.neighbors(adNorm, n_neighbors=n_neighbors, n_pcs=n_pcs)\nsc.tl.leiden(adNorm,.1)\nsc.tl.paga(adNorm)\nsc.pl.paga(adNorm, plot=False)\nsc.tl.umap(adNorm, 0.25, init_pos='paga')\nsc.pl.umap(adNorm,color=['leiden'], alpha=.75, s=15, legend_loc='on data')\n</pre> adNorm = adClean.copy()  ## Norm, HVG, PCA, kNN sc.pp.normalize_total(adNorm , target_sum=1e4) sc.pp.log1p(adNorm) sc.pp.highly_variable_genes(adNorm , min_mean=0.0125, max_mean=6, min_disp=0.25) sc.tl.pca(adNorm , use_highly_variable=True)  n_neighbors = 20 n_pcs = 10 sc.pp.neighbors(adNorm, n_neighbors=n_neighbors, n_pcs=n_pcs) sc.tl.leiden(adNorm,.1) sc.tl.paga(adNorm) sc.pl.paga(adNorm, plot=False) sc.tl.umap(adNorm, 0.25, init_pos='paga') sc.pl.umap(adNorm,color=['leiden'], alpha=.75, s=15, legend_loc='on data') <pre>/opt/homebrew/Caskroom/miniforge/base/envs/scnpy/lib/python3.12/site-packages/scanpy/preprocessing/_pca.py:374: FutureWarning: Argument `use_highly_variable` is deprecated, consider using the mask argument. Use_highly_variable=True can be called through mask_var=\"highly_variable\". Use_highly_variable=False can be called through mask_var=None\n  warn(msg, FutureWarning)\n/var/folders/1_/v5grqr5n7kj42276bb6ryxj00000gn/T/ipykernel_66578/3419511010.py:15: FutureWarning: The specified parameters ('min_dist',) are no longer positional. Please specify them like `min_dist=0.25`\n  sc.tl.umap(adNorm, 0.25, init_pos='paga')\n</pre> In\u00a0[46]: Copied! <pre>sc.pl.umap(adNorm , color=markerGenes, ncols=2)\n</pre> sc.pl.umap(adNorm , color=markerGenes, ncols=2) <p>Make a figure that shows the embedding and expression of marker genes side-by-side. Note that I am adding markers for T cell, B cell, and Monocyte sub-types</p> In\u00a0[47]: Copied! <pre>marker_genes_broad_dict = {\n    'B cell': ['CD79A', 'PAX5'],\n    'Dendritic': ['CLEC4C', 'FCER1A'],\n    'Monocyte': ['CSF1R', 'FCGR3A'],\n    'NK cell': ['NKG7', 'GNLY'],\n    'T cell': ['TRAC', 'CD3E'],\n}\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=['leiden'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> marker_genes_broad_dict = {     'B cell': ['CD79A', 'PAX5'],     'Dendritic': ['CLEC4C', 'FCER1A'],     'Monocyte': ['CSF1R', 'FCGR3A'],     'NK cell': ['NKG7', 'GNLY'],     'T cell': ['TRAC', 'CD3E'], }  fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=['leiden'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden', dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: dendrogram data not found (using key=dendrogram_leiden). Running `sc.tl.dendrogram` with default parameters. For fine tuning it is recommended to run `sc.tl.dendrogram` independently.\nWARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> In\u00a0[48]: Copied! <pre>sc.tl.leiden(adNorm,.1, restrict_to=[\"leiden\",[\"5\"]])\nsc.tl.dendrogram(adNorm, \"leiden_R\")\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> sc.tl.leiden(adNorm,.1, restrict_to=[\"leiden\",[\"5\"]]) sc.tl.dendrogram(adNorm, \"leiden_R\") fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> <p>Cluster 5 is split into 2 clusters now. Both of these sub-clusters express the Monocyte marker CD14, but are distinguished by their expression of dendritic marker FCER1A and the B cell genes CD79A and PAX5. Let's look at the QC metrics to see if that can give us additional hints as to whether these are real cells or are doublets.</p> In\u00a0[49]: Copied! <pre>sc.pl.violin(adNorm, ['total_counts'], groupby='leiden_R' )\n</pre> sc.pl.violin(adNorm, ['total_counts'], groupby='leiden_R' ) <p>Cluster 5 (and each sub-cluster) has a high number of Total counts. So let's annotate these as 'doublet'.</p> <p>What about the other questionable clusters 4 and 2? Can we refine those?</p> In\u00a0[50]: Copied! <pre># cluster 2 first\nsc.tl.leiden(adNorm,.05, restrict_to=[\"leiden\",[\"2\"]])\nsc.tl.dendrogram(adNorm, \"leiden_R\")\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> # cluster 2 first sc.tl.leiden(adNorm,.05, restrict_to=[\"leiden\",[\"2\"]]) sc.tl.dendrogram(adNorm, \"leiden_R\") fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2,0, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> <p>It looks like 2,0 is T cell, and 2,1 is Natural Killer cell. Note that 2,0 still has a distinct profile as compared to 0.</p> <p>What about cluster 4? And this time, when we do the sub-clustering, let's keep the way that we split up cluster 2.</p> In\u00a0[51]: Copied! <pre>sc.tl.leiden(adNorm,.1, restrict_to=[\"leiden_R\",[\"4\"]])\nsc.tl.dendrogram(adNorm, \"leiden_R\")\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> sc.tl.leiden(adNorm,.1, restrict_to=[\"leiden_R\",[\"4\"]]) sc.tl.dendrogram(adNorm, \"leiden_R\") fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2,0, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> <p>Is 4,1 multiplet?</p> In\u00a0[52]: Copied! <pre>sc.pl.violin(adNorm, ['total_counts', 'n_genes_by_counts'], groupby='leiden_R' )\n</pre> sc.pl.violin(adNorm, ['total_counts', 'n_genes_by_counts'], groupby='leiden_R' ) <p>Yes, it looks like 4,1 is similar in these QC profiles to cluster 5.</p> <p>So our updated annotation table is now:</p> cluster markers  of cell type 5 B, Dendritic, Mono doublet 1 Monocyte Monocyte 4,0 Monocyte Monocyte 3 B B-cell 6 Dendritic (B/Mono?) Dendritic cell 7 none Mystery cell 0 T cell T cell 2,0 T cell T cell 2,1 NK cell NK cell <p>Why do we have two Monocyte clusters and two T cells clusters?</p> In\u00a0[53]: Copied! <pre>marker_genes_sub_dict = {\n    'B cell': ['CD79A'],\n    'Dendritic': ['CLEC4C'],\n    'CD14 monocyte': ['CD14'],\n    'CD16 monocyte': ['FCGR3A'],\n    'NK cell': ['GNLY'],\n    'CD4 T cell': ['CD4', 'GATA3'],\n    'CD8 T cell': ['CD8A', 'EOMES']\n}\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_sub_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> marker_genes_sub_dict = {     'B cell': ['CD79A'],     'Dendritic': ['CLEC4C'],     'CD14 monocyte': ['CD14'],     'CD16 monocyte': ['FCGR3A'],     'NK cell': ['GNLY'],     'CD4 T cell': ['CD4', 'GATA3'],     'CD8 T cell': ['CD8A', 'EOMES'] }  fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_sub_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2,0, etc.\nvar_group_labels: B cell, Dendritic, CD14 monocyte, etc.\n</pre> <p>We are close to a final annotation now:</p> cluster markers  of cell type 5 B, Dendritic, Mono doublet 1 Monocyte CD14 Monocyte 4,0 Monocyte CD16 Monocyte 3 B B-cell 6 Dendritic (B/Mono?) Dendritic cell 7 none Mystery cell 0 T cell CD4 T cell 2,0 T cell CD8 T cell 2,1 NK cell NK cell <p>But what is cluster 7? It has low counts. If it is just ambient 'soup', then we would not expect it to have high levels of cell type specific genes. Let's do differential gene expression analysis to see what is upregulated in this cluster.</p> In\u00a0[54]: Copied! <pre>sc.tl.rank_genes_groups(adNorm, use_raw=False, groupby=\"leiden_R\")\n</pre> sc.tl.rank_genes_groups(adNorm, use_raw=False, groupby=\"leiden_R\") In\u00a0[55]: Copied! <pre>sc.pl.rank_genes_groups_dotplot(adNorm, n_genes=5, groupby=\"leiden_R\", dendrogram=True, key='rank_genes_groups')\n</pre> sc.pl.rank_genes_groups_dotplot(adNorm, n_genes=5, groupby=\"leiden_R\", dendrogram=True, key='rank_genes_groups') In\u00a0[56]: Copied! <pre>sc.pl.rank_genes_groups_dotplot(adNorm, n_genes=20, groupby=\"leiden_R\", dendrogram=True, key='rank_genes_groups', groups=['7'])\n</pre> sc.pl.rank_genes_groups_dotplot(adNorm, n_genes=20, groupby=\"leiden_R\", dendrogram=True, key='rank_genes_groups', groups=['7']) <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2,0, etc.\nvar_group_labels: 7\n</pre> <p>Although this result could be refined and explored a lot, it is sufficient for us to address our question about the identity of cluster 7 as follows:</p> Help from ChatGPT to annotate cells <p>Now, let's add the annotation to the anndata.obs and discard the other cells</p> cluster markers  of cell type 1 Monocyte CD14 Monocyte 4,0 Monocyte CD16 Monocyte 3 B B-cell 6 Dendritic (B/Mono?) Dendritic cell 7 none Platelet 0 T cell CD4 T cell 2,0 T cell CD8 T cell 2,1 NK cell NK cell In\u00a0[57]: Copied! <pre>tokeep = [\"1\", \"4,0\", \"3\", \"6\", \"7\", \"0\", \"2,0\", \"2,1\"]\nadNorm2 = adNorm.copy()\nadNorm2 = adNorm2[adNorm2.obs['leiden_R'].isin(tokeep)].copy()\nadNorm2.shape\nadNorm2.obs['leiden_R'].value_counts()\n</pre> tokeep = [\"1\", \"4,0\", \"3\", \"6\", \"7\", \"0\", \"2,0\", \"2,1\"] adNorm2 = adNorm.copy() adNorm2 = adNorm2[adNorm2.obs['leiden_R'].isin(tokeep)].copy() adNorm2.shape adNorm2.obs['leiden_R'].value_counts() Out[57]: <pre>leiden_R\n0      3563\n1      3115\n3      1604\n2,0    1031\n2,1     611\n4,0     368\n6        81\n7        60\nName: count, dtype: int64</pre> In\u00a0[58]: Copied! <pre>cell_dict = {'Dendritic': ['6'],\n             'CD14 Monocyte': ['1'],\n             'CD16 Monocyte': [\"4,0\"],\n             'B cell': ['3'],\n             'Platelet': ['7'],\n             'CD4 T cell': ['0'],\n             'CD8 T cell': [\"2,0\"],\n             'NK cell': [\"2,1\"]\n}\n\nmarker_genes_dict = {\n    'B cell': ['CD79A'],\n    'Dendritic': ['CLEC4C'],\n    'CD14 monocyte': ['CD14'],\n    'CD16 monocyte': ['FCGR3A'],\n    'NK cell': ['GNLY'],\n    'CD4 T cell': ['CD4', 'GATA3'],\n    'CD8 T cell': ['CD8A', 'EOMES'],\n    'Platelet': ['PF4', 'CAVIN2']\n}\n\n\nnew_obs_name = 'cell_type'\nadNorm2.obs[new_obs_name] = np.nan\n\nfor i in cell_dict.keys():\n    ind = pd.Series(adNorm2.obs.leiden_R).isin(cell_dict[i])\n    adNorm2.obs.loc[ind,new_obs_name] = i\n\nadNorm2.obs['cell_type'] = adNorm2.obs['cell_type'].astype(\"category\")\n</pre> cell_dict = {'Dendritic': ['6'],              'CD14 Monocyte': ['1'],              'CD16 Monocyte': [\"4,0\"],              'B cell': ['3'],              'Platelet': ['7'],              'CD4 T cell': ['0'],              'CD8 T cell': [\"2,0\"],              'NK cell': [\"2,1\"] }  marker_genes_dict = {     'B cell': ['CD79A'],     'Dendritic': ['CLEC4C'],     'CD14 monocyte': ['CD14'],     'CD16 monocyte': ['FCGR3A'],     'NK cell': ['GNLY'],     'CD4 T cell': ['CD4', 'GATA3'],     'CD8 T cell': ['CD8A', 'EOMES'],     'Platelet': ['PF4', 'CAVIN2'] }   new_obs_name = 'cell_type' adNorm2.obs[new_obs_name] = np.nan  for i in cell_dict.keys():     ind = pd.Series(adNorm2.obs.leiden_R).isin(cell_dict[i])     adNorm2.obs.loc[ind,new_obs_name] = i  adNorm2.obs['cell_type'] = adNorm2.obs['cell_type'].astype(\"category\")   <pre>/var/folders/1_/v5grqr5n7kj42276bb6ryxj00000gn/T/ipykernel_66578/4042500018.py:28: FutureWarning: Setting an item of incompatible dtype is deprecated and will raise an error in a future version of pandas. Value 'Dendritic' has dtype incompatible with float64, please explicitly cast to a compatible dtype first.\n  adNorm2.obs.loc[ind,new_obs_name] = i\n</pre> In\u00a0[59]: Copied! <pre>sc.tl.dendrogram(adNorm2, \"cell_type\")\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12,5), gridspec_kw={'wspace':0.4})\nax1_dict = sc.pl.umap(adNorm2,color=['cell_type'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm2, marker_genes_dict, 'cell_type', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> sc.tl.dendrogram(adNorm2, \"cell_type\") fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12,5), gridspec_kw={'wspace':0.4}) ax1_dict = sc.pl.umap(adNorm2,color=['cell_type'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm2, marker_genes_dict, 'cell_type', dendrogram=True,ax=ax2, show=False) plt.show()  <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: B cell, CD14 Monocyte, CD16 Monocyte, etc.\nvar_group_labels: B cell, Dendritic, CD14 monocyte, etc.\n</pre> In\u00a0[60]: Copied! <pre>sc.pl.pca(adNorm2, color=['cell_type', 'GNLY'], alpha=.75, s=15, projection='3d')\n</pre> sc.pl.pca(adNorm2, color=['cell_type', 'GNLY'], alpha=.75, s=15, projection='3d') In\u00a0[61]: Copied! <pre>sc.tl.rank_genes_groups(adNorm2, use_raw=False, groupby=\"cell_type\")\n</pre> sc.tl.rank_genes_groups(adNorm2, use_raw=False, groupby=\"cell_type\") In\u00a0[62]: Copied! <pre>sc.tl.filter_rank_genes_groups(adNorm2, min_fold_change=.7, min_in_group_fraction=.5, max_out_group_fraction=.15)\nsc.pl.rank_genes_groups_dotplot(adNorm2, n_genes=6, groupby=\"cell_type\", dendrogram=True, key='rank_genes_groups_filtered')\n</pre> sc.tl.filter_rank_genes_groups(adNorm2, min_fold_change=.7, min_in_group_fraction=.5, max_out_group_fraction=.15) sc.pl.rank_genes_groups_dotplot(adNorm2, n_genes=6, groupby=\"cell_type\", dendrogram=True, key='rank_genes_groups_filtered')"},{"location":"notebooks/scBasics.html#background-on-the-data","title":"Background on the data\u00b6","text":"<p>Let's start with some background + motivation for the data set that we are going to analyze: hematopoietic cells from peripheral blood.</p>"},{"location":"notebooks/scBasics.html#hematopoiesis","title":"Hematopoiesis\u00b6","text":"Traditional model of hematopoiesis. Image from Slack 2017 <p>These cells are produced in the bone marrow and then move into the vascular so that they can move about the body and perform their functions (transport oxygen, clot, do adaptive and innate immune things).</p>"},{"location":"notebooks/scBasics.html#peripheral-blood-mononuclear-cells-pbmcs","title":"Peripheral blood mononuclear cells (PBMCs)\u00b6","text":"<p>It is possible to enrich for what are called PBMCs from vein by subjecting sample to density gradient centrifugation. This enrichs for cells that have one, round nucleus, and excludes cells that do not have nuclie, or that have multi-lobed structures. PBMCs typically contain:</p> <p>... several classes of immune cells, including T cells (~70%), B cells (~15%), monocytes (~5%), dendritic cells (~1%) and natural killer (NK) cells (~10%)     --  Sen et al 2019</p> <p>and</p> <p>... The CD3+ lymphocytes are composed of CD4+ and CD8+ T cells, roughly in a 2:1 ratio.     -- Kleiveland, 2015</p>"},{"location":"notebooks/scBasics.html#bio-questions-for-the-day","title":"Bio question(s) for the day\u00b6","text":"<ul> <li>What does scRNAseq estimate as their relative proportion? and how does it compare to the estimate above?</li> <li>To what extent does cell type composition vary between samples?</li> <li>Are there other genes that are better at distinguishing between these populations than marker genes listed below?</li> <li>How many cells do you need to reliably detect a sub-population?</li> </ul>"},{"location":"notebooks/scBasics.html#data","title":"Data\u00b6","text":"<p>10X Genomics scRNA-seq on human PBMCs</p>"},{"location":"notebooks/scBasics.html#sample-1","title":"Sample 1\u00b6","text":"<ul> <li>http://cf.10xgenomics.com/samples/cell-exp/1.1.0/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz</li> </ul>"},{"location":"notebooks/scBasics.html#sample-2","title":"Sample 2\u00b6","text":"<ul> <li>https://colab.research.google.com/corgiredirector?site=https%3A%2F%2Fcf.10xgenomics.com%2Fsamples%2Fcell-exp%2F6.1.0%2F20k_PBMC_3p_HT_nextgem_Chromium_X%2F20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5</li> <li>20k Human PBMCs, 3\u2019 HT v3.1, Chromium X</li> <li>Sourced from a healthy female donor</li> <li>23,837 cells</li> <li>35,000 reads per cell</li> <li>Filtered data in .h5 format</li> </ul>"},{"location":"notebooks/scBasics.html#cellranger","title":"CellRanger\u00b6","text":"<p>CellRanger is the program that converts sequencing reads into gene expression counts.</p> CellRanger flow chart from 10X genomics"},{"location":"notebooks/scBasics.html#installation","title":"Installation\u00b6","text":"<p>If you choose to analyze data from your own computer, please use an environment manager like conda.</p>"},{"location":"notebooks/scBasics.html#fetch-data-files","title":"Fetch data file(s)\u00b6","text":""},{"location":"notebooks/scBasics.html#scanpy-basics","title":"Scanpy basics\u00b6","text":""},{"location":"notebooks/scBasics.html#load-packages","title":"load packages\u00b6","text":""},{"location":"notebooks/scBasics.html#load-sample-1","title":"Load Sample 1\u00b6","text":""},{"location":"notebooks/scBasics.html#getting-information-about-functions","title":"Getting information about functions\u00b6","text":"<p>You can get info about functions using</p> <p>help(functionName)</p> <p>or</p> <p>?functionName</p>"},{"location":"notebooks/scBasics.html#inspecting-the-data-gross-properties","title":"Inspecting the data -- gross properties\u00b6","text":""},{"location":"notebooks/scBasics.html#package-documentation","title":"Package documentation\u00b6","text":"<p>Often, the best source of help is the package's documentation.</p> <p>Scanpy's documentation</p>"},{"location":"notebooks/scBasics.html#anndata","title":"AnnData\u00b6","text":"<p>AnnData is a Python package that defines a data structure designed to efficiently store large data sets like scRNA-seq.</p> AnnData schema. AnnData documentation. See Resouces below for more"},{"location":"notebooks/scBasics.html#slicing-or-subsetting","title":"Slicing or subsetting\u00b6","text":"<p>There are lots of ways to get parts of an adata obkect. Here, let's randomly select a subset of cells and genes.</p>"},{"location":"notebooks/scBasics.html#gene-counts","title":"Gene counts\u00b6","text":"<p>So, where is the data?</p>"},{"location":"notebooks/scBasics.html#the-metadata","title":"The Metadata\u00b6","text":"<ul> <li>for cells, see .obs</li> <li>for genesm see .var</li> </ul>"},{"location":"notebooks/scBasics.html#loc","title":".loc\u00b6","text":"<p>.obs and .var are Pandas dataframes and so you can access subsets of them using .loc and .iloc</p>"},{"location":"notebooks/scBasics.html#quality-control-qc","title":"Quality Control (QC)\u00b6","text":"<p>Broadly speaking there are two things that we apply quality control to:</p> <ol> <li>Cells: We want to find putative doublets and low quality cell barcodes and hold them out of downstram analysis.</li> <li>Genes: We also can remove genes that are not detected in vast majority of cell</li> </ol> <p>The function <code>sc.pp.calculate_qc_metrics()</code> will calculate a set of metrics on adata and place the results in .obs or .var. The results can then be used to filter the adata. <code>pp.calculate_qc_metrics()</code> can also take inputs to specify other, custom metrics to compute.</p> <p>Below, we use it to compute the fraction of all UMIs in each cell that are mitochondrially encoded or that encode for ribosomal genes.</p>"},{"location":"notebooks/scBasics.html#visualize","title":"Visualize\u00b6","text":"<p>Take a look some typical QC values across these data</p>"},{"location":"notebooks/scBasics.html#normalization","title":"Normalization\u00b6","text":"<p>Simple library size scaling, then log transform. There are many other ways to correct for cell-to-cell technical variation, for example different cell lysis efficiencies, but this method is good enough for this data set and our goals.</p>"},{"location":"notebooks/scBasics.html#highly-variable-genes-hvg","title":"Highly variable genes (HVG)\u00b6","text":"<p>It is common practice to limit some parts of analysis to those variables/genes that exhibit some degree of variation in their values across the data. We call these highly variable genes, or HVG for short. To find these, calculate some gene statistics, which when combined with thresholds below, determine which genes are considered HVG. The relevant metrics are:</p> <ol> <li>mean expression</li> <li>dispersion, which is the variance / mean.</li> </ol> <p>Variance is defined as the expected squared deviation of gene expression. The normalized dispersion is calculated by scaling based on a bin of mean expression.</p>"},{"location":"notebooks/scBasics.html#dimensionality-reduction-with-principal-components-analysis-pca","title":"Dimensionality reduction with Principal components analysis (PCA)\u00b6","text":"<p>Why performan dimentaionality reduction?</p> <ol> <li>Genes are expressed in coordinated fashion, meaning that many have correlated expression patterns and so PCA reduces the computational complexity of downstream analysis</li> <li>scRNA-seq data is noisy on a per gene basis.</li> </ol> <p>PCA allows us to reduce a high dimensional data set into a lower dimension in which much of the total variation is maintained. To understand PCA, you need to know linear algebra. In essence, it identifies sets of linear combinations of genes in such a way that a PC is uncorrelated with other PCs and that explains most variation in the data. The function call <code>sc.tl.pca</code> does the following:</p> <ol> <li>computes the covariance matrix (correlation between each pair of genes)</li> <li>finds eigenvectors (directions of axes that maximize that variance), orthogonal to each other</li> </ol> <p>Later, we select a threshold (n_pcs) as the number of PCs that contribute most to the total variation on our data. We use these n_pcs PCs to compute cell-to-cell distances for embedding (2D visualization via UMAP) and for clustering of cells.</p>"},{"location":"notebooks/scBasics.html#marker-genes","title":"Marker genes\u00b6","text":"<p>Here PBMC cell types and some genes that have been used to identify them: Monocytes: CD14, CD68, LYZ Dendritic: CLEC4C, FLT3 NK cells: GNLY, NCAM1 B cells: CD19, CD79A, CD79B T cells: CD3D, CD3E, TRAC, TRBC</p>"},{"location":"notebooks/scBasics.html#pca-loadings","title":"PCA Loadings\u00b6","text":"<p>Where are PCs (i.e. loadings -- the contribution of each gene to each PC) stored in anndata? .varm (see figure of anndata way above)?</p>"},{"location":"notebooks/scBasics.html#knn-cell-cell-distances","title":"kNN cell-cell distances\u00b6","text":"<p>The k-nearest neighbor graph generates an adjacency matrix by finding, for each cell, the k cells that are closest to it. This helps to reduce noise in computing cell-cell distances or similarities and is important for embedding the cells in a 2D space, and for community detection algorithms. Two arguments are n_neighbors, or k, and the number of PCs to use when computing cell-cell distances.</p>"},{"location":"notebooks/scBasics.html#visualization-of-cell-cell-similarities","title":"Visualization of cell-cell similarities\u00b6","text":""},{"location":"notebooks/scBasics.html#umap-embedding","title":"UMAP embedding\u00b6","text":"<p>This an elaboration on the t-SNE embedding approach. Both of these methods try to project cells into a reduced (typically 2) dimensional coordinate system while maintaining both the global and local structure of the high dimensional space of the data (i.e. cells that are distant from each other high dimensions should still be distant in the reduced embedding; same is true for cells that are near each other). The distances come from the kNN graph.</p>"},{"location":"notebooks/scBasics.html#unsupervised-clustering","title":"Unsupervised clustering\u00b6","text":"<p>Let's try to assign cells to distinct groups or clusters based on the cell-to-cell distances. Leiden and Louvain are examples of community detection methods that perform this task by searching for the group assignment that maximize within group similarity (which is equivalent to within group edges of a knn graph) and to minimize between group similarity.</p>"},{"location":"notebooks/scBasics.html#cluster-annotation","title":"Cluster annotation\u00b6","text":"<p>We can walk down the rows of the dotplot and guess at the cell types of some of these clusters based on the specificty of marker expression:</p> cluster markers  of cell type 5 B, Dendritic, Mono ??? 1 Monocyte Monocyte 4 Monocyte, T ??? 3 B B-cell 6 Dendritic (B/Mono?) Dendritic cell 7 none Mystery cell 0 T cell T cell 2 NK/T ??? <p>Some clusters are ambiguous because they express markers of more than one cell type. This could be due to the cluster containing &gt; 1 cell type, or because the cell barcodes are doublets. If the former, then we should be able to sub cluster them. Let's try this.</p> <p>Clusters to refine are 5, 4, and 2.</p>"},{"location":"notebooks/scBasics.html#differential-gene-expression","title":"Differential gene expression\u00b6","text":""},{"location":"notebooks/scBasics.html#differential-expression-analysis","title":"Differential expression analysis\u00b6","text":"<p>Let's identify genes that are preferenntially expressed in each cluster versus all the others as a final step to annotate these clusters and to remove ones that are likely to be doublets.</p>"},{"location":"notebooks/scBasics.html#dot-plot-of-differentially-expressed-genes","title":"Dot plot of differentially expressed genes\u00b6","text":"<p>First, we will apply a filter so that we only display genes that meet additional criteria beyond statistical: fold change, % expressed in cluster, % expressed in other cells</p>"},{"location":"notebooks/scBasics.html#resources","title":"Resources\u00b6","text":""},{"location":"notebooks/scBasics.html#tools","title":"Tools\u00b6","text":"<ul> <li>Colab<ul> <li>https://colab.research.google.com/</li> </ul> </li> <li>Jupyter<ul> <li>https://jupyter.org/</li> </ul> </li> <li>CellRanger<ul> <li>https://www.10xgenomics.com/support/software/cell-ranger/latest/advanced/cr-barcode-rank-plot</li> <li>https://www.10xgenomics.com/support/software/cell-ranger/latest/algorithms-overview/cr-gex-algorithm</li> </ul> </li> </ul>"},{"location":"notebooks/scBasics.html#literature","title":"Literature\u00b6","text":"<ul> <li>Best practices<ul> <li>best practices in sc analysis online book</li> <li>paper associated with the above online book</li> </ul> </li> <li>Scanpy<ul> <li>https://scanpy.readthedocs.io/en/stable/</li> <li>https://scanpy.readthedocs.io/en/stable/tutorials.html</li> <li>https://scanpy-tutorials.readthedocs.io/en/latest/pbmc3k.html</li> <li>https://scanpy-tutorials.readthedocs.io/en/latest/plotting/advanced.html</li> <li>https://scanpy-tutorials.readthedocs.io/en/latest/plotting/core.html</li> </ul> </li> <li>AnnData<ul> <li>https://anndata.readthedocs.io/en/latest/tutorials/notebooks/getting-started.html</li> <li>https://anndata.readthedocs.io/en/latest/index.html</li> </ul> </li> <li>QC<ul> <li>https://genomebiology.biomedcentral.com/articles/10.1186/s13059-020-02136-7</li> </ul> </li> </ul>"}]}